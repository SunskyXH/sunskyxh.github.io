<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Bonfire</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="tech blog, Front End, Web Develope" />
  
  
  
  
  <meta name="description" content="香香鸡的小窝">
<meta property="og:type" content="website">
<meta property="og:title" content="Bonfire">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Bonfire">
<meta property="og:description" content="香香鸡的小窝">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Bonfire">
<meta name="twitter:description" content="香香鸡的小窝">
  
    <link rel="alternate" href="/atom.xml" title="Bonfire" type="application/atom+xml">
  
  <link rel="icon" href="/http://olu3hx27t.bkt.clouddn.com/image/sun.png">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >

  
    <link rel="stylesheet" href="/css/home.css" >
  

  

  

</head>

<body>
  
    <header id="header">

  
    <div id="intrologo" class="intro-logo" style="background-position:center; background-repeat:no-repeat; background-image: url(); background-size: auto 100%;">
    <script>
        var imgUrls = "http://olu3hx27t.bkt.clouddn.com/image/solar.jpg".split(",");
        var random = Math.floor((Math.random() * imgUrls.length ));
        if (imgUrls[random].startsWith('http') || imgUrls[random].indexOf('://') >= 0) {
          document.getElementById("intrologo").style.backgroundImage='url(' + imgUrls[random] + ')';
        } else {
          document.getElementById("intrologo").style.backgroundImage='url(/' + imgUrls[random] + ')';
        }
    </script>
  

    <canvas width="100%" height="100%"></canvas>
    <script>
      var c = document.getElementsByTagName('canvas')[0],
          x = c.getContext('2d'),
          w = window.innerWidth,
          h = window.innerHeight,
          pr = window.devicePixelRatio || 1,
          f = 90,
          q,
          m = Math,
          r = 0,
          u = m.PI*2,
          v = m.cos,
          z = m.random
      c.width = w*pr
      c.height = h*pr
      x.scale(pr, pr)
      x.globalAlpha = 0.6

      
    </script>
    

    
      <div id="homelogo" class="homelogo" style="background: rgba(255,255,255,1);"> 
    

        
          <div class="homelogoback"  style="border: 1px solid #404040;" >
            <h1><a href="#content" id="logo">Bonfire</a></h1>
            <h3>香香鸡的小窝</h3>
            <h5>SunskyXH</h5>
          </div>
        
    
    </div>
  </div>

  <!-- 自适应主页背景大图 -->
  
    <script>
        var img = new Image();
        var intrologodiv = document.getElementById("intrologo");
        img.src = intrologodiv.style.backgroundImage.replace('url(','').replace(')','').replace(/\"/gi, "");
        img.onload=function(){
          if (img.width / img.height <= document.body.clientWidth / document.body.clientHeight) {
            intrologodiv.style.backgroundSize = "100% auto";
          } else {
            intrologodiv.style.backgroundSize = "auto 100%";
          }
        };
    </script>
 

 <!-- home_logo_image居中 -->
 
    <script>
        var homelogodiv = document.getElementById("homelogo");
        if (document.all.homelogo.offsetWidth > document.body.clientWidth) {
          homelogodiv.style.width = document.body.clientWidth + "px";
          homelogodiv.style.marginLeft = document.body.clientWidth * -0.5 + "px";
        } else {
          homelogodiv.style.width = homelogodiv.clientWidth  + "px";
          homelogodiv.style.marginLeft = (homelogodiv.clientWidth)  * -0.5 + "px";
        }
    </script>
  

  <div class="intro-navigate">
      <p class="navigater-list">
        
          <a id="beautifont" class="main-nav-link" href="/">Home</a>
        
          <a id="beautifont" class="main-nav-link" href="/archives">Archives</a>
        
          <a id="beautifont" class="main-nav-link" href="/categories">Categories</a>
        
          <a id="beautifont" class="main-nav-link" href="/tags">Tags</a>
        
          <a id="beautifont" class="main-nav-link" href="/about">About</a>
        
          <a id="beautifont" class="main-nav-link" href="https://github.com/SunskyXH/">Github</a>
      </p>
  </div>

</header>
  
  <div id="container">
    <div id="wrap">
      
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;">
  
    <article id="post-6-reasons-why-javascripts-async-await-blows-promises-away"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/05/6-reasons-why-javascripts-async-await-blows-promises-away/">6个Async/Await胜过Promise的理由（自译）</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/05/6-reasons-why-javascripts-async-await-blows-promises-away/" class="article-date">
	  <time datetime="2017-04-04T17:28:56.000Z" itemprop="datePublished">2017-04-05</time>
	</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://hackernoon.com/6-reasons-why-javascripts-async-await-blows-promises-away-tutorial-c7ec10518dd9" target="_blank" rel="external">原文链接</a></p>
<blockquote>
<p>In case you missed it, Node now supports async/await out of the box since version 7.6. If you haven’t tried it yet, here are a bunch of reasons with examples why you should adopt it immediately and never look back.</p>
</blockquote>
<p>如果你错过了它，Node7.6现在已经支持async/await。如果你至今还没有试过，本文将会有许多理由和例子来为什么你应该马上使用async/await并且再也不回想过去。</p>
<blockquote>
<h3 id="Async-await-101"><a href="#Async-await-101" class="headerlink" title="Async/await 101"></a>Async/await 101</h3><p>For those who have never heard of this topic before, here’s a quick intro</p>
<ul>
<li>Async/await is a new way to write asynchronous code. Previous options for asynchronous code are callbacks and promises.</li>
<li>Async/await is actually built on top of promises. It cannot be used with plain callbacks or node callbacks.</li>
<li>Async/await is, like promises, non blocking.</li>
<li>Async/await makes asynchronous code look and behave a little more like synchronous code. This is where all its power lies.</li>
</ul>
</blockquote>
<h3 id="Async-await基础"><a href="#Async-await基础" class="headerlink" title="Async/await基础"></a>Async/await基础</h3><p>这里给没有从没用过async/await的读者进行一个简单的介绍</p>
<ul>
<li>async/await是一种书写异步代码的新方法，在这之前使用回调函数和promise来设置异步代码。</li>
<li>async/await实际上是在promise的基础上构建的，他不能和纯回调函数(plain callbacks)和节点回调函数(node callbacks)一起使用。</li>
<li>async/await很像promise，不会出现代码块。</li>
<li>async/await让异步代码的外观和行为像同步代码。这就是他厉害的地方。</li>
</ul>
<blockquote>
<h3 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h3><p>Assuming a function getJSON that returns a promise, and that promise resolves with some JSON object. We just want to call it and log that JSON, then return “done”.<br>This is how you would implement it using promises</p>
</blockquote>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>假设一个函数<code>getJSON</code>返回一个promise，并且该promise会去reslove一些JSON对象，我们只是像简单的调用它并且打印该JSON，之后再返回<code>&quot;done&quot;</code>。</p>
<p>你可能用promise这样去实现<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> makeRequest= <span class="function"><span class="params">()</span> =&gt;</span></div><div class="line">  getJSON()</div><div class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</div><div class="line">      <span class="built_in">console</span>.log(data)</div><div class="line">      <span class="keyword">return</span> <span class="string">"done"</span></div><div class="line">    &#125;)</div><div class="line">makeRequest()</div></pre></td></tr></table></figure></p>
<blockquote>
<p>And this is how it looks with async/await</p>
</blockquote>
<p>用async/await会长这样<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> makeRequest = <span class="keyword">async</span> () =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> getJSON())</div><div class="line">  <span class="keyword">return</span> <span class="string">"done"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">makeRequest()</div></pre></td></tr></table></figure></p>
<blockquote>
<p>There are a few differences here</p>
<ol>
<li>Our function has the keyword async before it. The await keyword can only be used inside functions defined with async. Any async function returns a promise implicitly, and the resolve value of the promise will be whatever you return from the function (which is the string “done” in our case).</li>
<li>The above point implies that we can’t use await in the top level of our code since that is not inside an async function.</li>
<li>await getJSON() means that the console.log call will wait until getJSON() promise resolves and print it value.</li>
</ol>
</blockquote>
<p>有几点不同</p>
<ol>
<li>我们的函数前面有一个关键字<code>async</code>，<code>await</code>关键字只能在<code>async</code>定义的函数内部使用，任何<code>async</code>函数返回一个隐式的promise，并且这个promise的resolve将会是这个函数中的<code>return</code>（在上例中是字符串<code>&quot;node&quot;</code>）。</li>
<li><p>前面一点暗示了我们不能在代码的最外层使用await，因为那不再一个<code>async</code>函数内部。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// this will not work in top level</span></div><div class="line"><span class="comment">// await makeRequest()</span></div><div class="line"></div><div class="line"><span class="comment">// this will work</span></div><div class="line">makeRequest().then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</div><div class="line">  <span class="comment">// do something</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p><code>await getJSON()</code>意味着<code>console.log()</code>的调用会等到<code>getJSON()</code>resolve之后。</p>
</li>
</ol>
<blockquote>
<h3 id="Why-Is-It-better"><a href="#Why-Is-It-better" class="headerlink" title="Why Is It better?"></a>Why Is It better?</h3><ol>
<li>Concise and clean<br>Look at how much code we didn’t write! Even in the contrived example above, it’s clear we saved a decent amount of code. We didn’t have to write .then, create an anonymous function to handle the response, or give a name data to a variable that we don’t need to use. We also avoided nesting our code. These small advantages add up quickly, which will become more obvious in the following code examples.</li>
</ol>
</blockquote>
<h3 id="为什么async-await更好？"><a href="#为什么async-await更好？" class="headerlink" title="为什么async/await更好？"></a>为什么async/await更好？</h3><ol>
<li>简洁干净<br>看一看我们少写了多少代码！甚至在上面故意这样写的例子里，显然我们节省了大量代码。我们不用写<code>.then</code>，不用创建一个匿名函数来处理response，或者是给<code>data</code>赋值给一个我们不需要的变量，我们也避免了嵌套代码。这些小的优点汇聚起来，将在接下来的例子中更加明显。</li>
</ol>
<blockquote>
<ol>
<li>Error handling<br>Async/await makes it finally possible to handle both synchronous and asynchronous errors with the same construct, good old try/catch. In the example below with promises, the try/catch will not handle if JSON.parse fails because it’s happening inside a promise. We need to call .catch on the promise and duplicate our error handling code, which will (hopefully) be more sophisticated than console.log in your production ready code.</li>
</ol>
</blockquote>
<ol>
<li>错误处理<br>async/await 终于让使用同样的结构，好并且成熟的<code>try/catch</code>来处理同步和异步错误成为可能。在下面使用promise的例子中</li>
</ol>

      
    </div>
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>

    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-preact-virtual-DOM-algorithm-explore"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/02/26/preact-virtual-DOM-algorithm-explore/">Preact Virtual DOM算法探究</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/02/26/preact-virtual-DOM-algorithm-explore/" class="article-date">
	  <time datetime="2017-02-26T05:50:19.000Z" itemprop="datePublished">2017-02-26</time>
	</a>

      
    <a class="article-category-link" href="/categories/front-end/">front-end</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Preact简介"><a href="#Preact简介" class="headerlink" title="Preact简介"></a>Preact简介</h3><p><img src="http://olu3hx27t.bkt.clouddn.com/image/preact.png?imageView2/2/w/200/h/100" alt=""><br>Preact是一个React轻量化的库，整个库大小只有3kb，相比其他react轻量化的方案，如25kb的<a href="https://github.com/Lucifier129/react-lite" target="_blank" rel="external">react-lite</a>，Preact在体积上有着很大的优势。<br>Preact有着和React相似的API，大部分情况下能兼容React的组件，只需要绑定一个preact-compat兼容层就能解决很多兼容问题。类似React的生态圈，Preact自己也有着规模不小的生态圈。<br>同时官网也宣称Preact有着一个简单却高效的diff算法实现使他成为最快的虚拟DOM框架之一，官网也号称自己可能是最薄的一层虚拟DOM实现。接下来本文将简单探究一下preact的虚拟DOM算法</p>
<h3 id="Preact的Virtual-DOM实现"><a href="#Preact的Virtual-DOM实现" class="headerlink" title="Preact的Virtual DOM实现"></a>Preact的Virtual DOM实现</h3><p>React使用<code>React.createElement()</code>来实现js转换为Virtual DOM的过程，Preact在这里用了自己的实现方式。<br>Preact的Virtual DOM实现使用了<a href="https://www.npmjs.com/package/babel-plugin-transform-react-jsx" target="_blank" rel="external">babel-plugin-transform-react-jsx</a>，通过pragma注入一个函数<code>preact.h</code>，实现类似下面的转换<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** @jsx h */</span></div><div class="line"><span class="keyword">let</span> foo = &lt;div id='foo'&gt;Hello&lt;/div&gt;</div><div class="line"></div><div class="line"><span class="comment">//After babel transpilation</span></div><div class="line"><span class="keyword">var</span> foo = h(<span class="string">'div'</span>, &#123;<span class="attr">id</span>: <span class="string">'foo'</span>&#125;, <span class="string">'Hello'</span>);</div></pre></td></tr></table></figure></p>
<p>Preact利用<code>Preact.h()</code>函数来将转换后的js生成Virtual DOM，之后再利用自己的Virtual DOM算法将其转换为真实的DOM。<br>Preact.h()这个函数为<a href="https://github.com/hyperhype/hyperscript" target="_blank" rel="external">hyperscript</a>的一个简化版，有兴趣的读者可以去了解完整的hyperscript。</p>
<h3 id="Preact的Virtual-DOM算法"><a href="#Preact的Virtual-DOM算法" class="headerlink" title="Preact的Virtual DOM算法"></a>Preact的Virtual DOM算法</h3><h4 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h4><p>h函数接受babel转换后的代码，生成一系列的VNode(也就是Virtual DOM)，之后执行<code>render()</code>函数，例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">render(h(Foo), <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>))</div></pre></td></tr></table></figure></p>
<p>h()函数会将Foo转为如下的VNode<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"nodeName"</span>: <span class="string">"Foo"</span>,</div><div class="line">    <span class="attr">"children"</span>: []</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>之后会根据VNode.nodeName的类型分为以下几种情况</p>
<h5 id="为组件创建VNode的实例"><a href="#为组件创建VNode的实例" class="headerlink" title="为组件创建VNode的实例"></a>为组件创建VNode的实例</h5><p>如果当前这个VNode.nodeName是一个组件，且还未被实例化，则会先去创建这个组件的实例，然后去先后调用这个组件的<code>componentWillMount</code>和<code>render</code>生命周期，其中<code>render()</code>会多次调用<code>h()</code>函数，最终让VNode变成类似下面的结构<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"nodeName"</span>: <span class="string">"div"</span>,</div><div class="line">    <span class="attr">"children"</span>: [</div><div class="line">        &#123;</div><div class="line">            <span class="attr">"nodeName"</span>: <span class="string">"input"</span>,</div><div class="line">            <span class="attr">"attribute"</span>: &#123;</div><div class="line">                <span class="attr">"type"</span>: <span class="string">"text"</span>,</div><div class="line">                <span class="attr">"onChange"</span>: <span class="string">""</span>,</div><div class="line">                <span class="attr">"placeholder"</span>: <span class="string">"input here"</span></div><div class="line">            &#125;,</div><div class="line">            <span class="attr">"children"</span>: []</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            <span class="attr">"nodeName"</span>: <span class="string">"List"</span>,</div><div class="line">            <span class="attr">"attribute"</span>: &#123;</div><div class="line">                <span class="attr">"items"</span>: [</div><div class="line">                    <span class="string">"foo"</span>,</div><div class="line">                    <span class="string">"bar"</span>,</div><div class="line">                ]</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">"children"</span>: []</div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>需要注意的是，上面的节点的第二个子节点为一个组件，在这里并没有被转换。<br><code>render()</code>函数执行完后会又重复根据VNode.nodeName类型进行判断</p>
<p>与组件相关的函数一共有四个，分别为</p>
<ul>
<li><code>setComponentProps()</code>: 为组件设立props</li>
<li><code>renderComponent()</code>: 渲染一个组件，在这个函数内部会触发一些生命周期的钩子以及接收高阶组件</li>
<li><code>buildComponentFromVNode()</code>: 将来自VNode的组件变为真实DOM</li>
<li><code>unmoumtComponent()</code>: 将组件从DOM树中移除，并回收它</li>
</ul>
<h5 id="为非组件直接创建真实DOM节点"><a href="#为非组件直接创建真实DOM节点" class="headerlink" title="为非组件直接创建真实DOM节点"></a>为非组件直接创建真实DOM节点</h5><p>当VNode.nodeName为非组件(即HTML标签)，且还没有相同的真实DOM节点已经被渲染，则会去用<code>document.createNode(node)</code>创建新的节点。<br>如果这个节点还有子节点的话，则会循环这个过程来重复创建子节点。</p>
<h5 id="子节点添加到父节点"><a href="#子节点添加到父节点" class="headerlink" title="子节点添加到父节点"></a>子节点添加到父节点</h5><p>当上一步中判断节点没有子节点时，会接着判断该节点是否有父节点，若有父节点则会调用父节点的<code>appendChild(childNode)</code>方法来将子节点添加到父节点。</p>
<blockquote>
<p>创建完子节点A（A无子节点）后并不会立即去创建子节点B，而是会先将子节点A添加到父节点，再去创建子节点B</p>
</blockquote>
<h5 id="处理子组件"><a href="#处理子组件" class="headerlink" title="处理子组件"></a>处理子组件</h5><p>当子节点为一个组件时，流程与前面类似，先为该组件创建VNode，再对其子节点进行前面流程的操作。<br>最终处理完该组件(以前面的List组件为例)的VNode类似如下结构：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"nodeName"</span>: <span class="string">"ul"</span>,</div><div class="line">    <span class="attr">"children"</span>: [</div><div class="line">        &#123;</div><div class="line">            <span class="attr">"nodeName"</span>: <span class="string">"li"</span>,</div><div class="line">            <span class="attr">"attribute"</span>: &#123;</div><div class="line">                <span class="attr">"key"</span>: <span class="string">"foo"</span></div><div class="line">            &#125;,</div><div class="line">            <span class="attr">"children"</span>: [</div><div class="line">                <span class="string">"foo"</span></div><div class="line">            ],</div><div class="line">            <span class="attr">"key"</span>: <span class="string">"foo"</span></div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            <span class="attr">"nodeName"</span>: <span class="string">"li"</span>,</div><div class="line">            <span class="attr">"attribute"</span>: &#123;</div><div class="line">                <span class="attr">"key"</span>: <span class="string">"bar"</span></div><div class="line">            &#125;,</div><div class="line">            <span class="attr">"children"</span>: [</div><div class="line">                <span class="string">"bar"</span></div><div class="line">            ],</div><div class="line">            <span class="attr">"key"</span>: <span class="string">"bar"</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="结束处理"><a href="#结束处理" class="headerlink" title="结束处理"></a>结束处理</h5><p>多次重复前面的流程，所有的节点以及挂载之后（即当前处理的VNode没有父节点），会调用<code>componentDidMount</code>函数，结束处理。</p>
<blockquote>
<p>在这之后，组件会保持一个对真实DOM的引用(refs)，引用会用于更新和对比，能避免重复创建相同的节点。</p>
</blockquote>
<h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><p>删除节点的过程中，涉及到了组件的更新、删除节点和组件的卸载</p>
<h5 id="更新VNode"><a href="#更新VNode" class="headerlink" title="更新VNode"></a>更新VNode</h5><p>在判断完VNode.nodeName为组件并且该组件以及存在后，会去先后调用<code>componentWillReceiveProps</code>, <code>shouldComponentUpdate</code>和<code>componentWillUpdate</code>的生命钩子，之后再去调用<code>render</code></p>
<blockquote>
<p>如果在这个流程中<code>shouldComponentUpdate</code>返回了false，则会直接跳过<code>componentWillUpdate</code>和<code>render</code>，这也就是<code>shouldComponentUpdate</code>用于优化react／preact性能的原理。</p>
</blockquote>
<h5 id="引用真实DOM"><a href="#引用真实DOM" class="headerlink" title="引用真实DOM"></a>引用真实DOM</h5><p>先前已经创建过的组件会保持对真实DOM的引用，在更新后，他的每一个属性都会和真实DOM的属性比较，如果是没有变化，则会跳过这个节点，去处理下一个节点，从而实现避免重复创建。</p>
<h5 id="完全删除节点"><a href="#完全删除节点" class="headerlink" title="完全删除节点"></a>完全删除节点</h5><p>当节点找不到与之相同的真实DOM，也不在创建节点的情况下，则会去删除(remove)该节点。<br>该节点不为组件的情况下，其父节点会简单的调用<code>removeChild(node)</code>来删除节点，在这之后会触发<code>ComponentDidUpdate</code>生命钩子。</p>
<h5 id="卸载组件"><a href="#卸载组件" class="headerlink" title="卸载组件"></a>卸载组件</h5><p>类似上面完全删除节点的情况，如果即将删除的为一个组件，则会先调用<code>ComponentWillUnMount</code>，之后去调用<code>component.unmoumtComponent()</code>，删除完之后调用<code>ComponentDidMounted</code>。</p>
<h4 id="DOM-Diff"><a href="#DOM-Diff" class="headerlink" title="DOM Diff"></a>DOM Diff</h4><p>上面的Virtual DOM算法在具体实现中会多次用到DOM Diff算法进行对比。<br>在探索Preact的DOM Diff算法之前，先简单了解一下React的DOM Diff算法：</p>
<h5 id="React的DOM-Diff算法"><a href="#React的DOM-Diff算法" class="headerlink" title="React的DOM Diff算法"></a>React的DOM Diff算法</h5><p>React的DOM Diff算法在标准Diff算法的基础上改进，将时间复杂度从O(n^3)减少到了O(n)，能做到这样是因为React的diff算法基于了两点假设：</p>
<blockquote>
<p>1.Two elements of different types will produce different trees.<br>  两个不同类型的元素会生成不同的DOM树<br>2.The developer can hint at which child elements may be stable across different renders with a key prop.<br>  开发者可以用给子元素加上<code>key</code>这个prop来让其能在多次渲染时保持稳定<br>  (关于第二点，网上部分资料给出的为 对于同一层次的一组子节点，它们可以通过唯一的id进行区分)</p>
</blockquote>
<p>其DOM Diff算法主要分为三类情况，tree diff，component diff和element diff。<br>（关于React DOM Diff的文章很多，本文就不在这里赘述）</p>
<h5 id="Preact的DOM-Diff算法"><a href="#Preact的DOM-Diff算法" class="headerlink" title="Preact的DOM Diff算法"></a>Preact的DOM Diff算法</h5><p>阅读过源码的读者不难发现，前面提到的<code>render()</code>函数本质上是调用了diff函数，而diff函数的具体实现中会涉及到以下函数</p>
<ul>
<li><code>idiff()</code>：<code>diff()</code>主要会调用这个函数，去进行具体的对比</li>
<li><code>diffAttributes()</code>：对比节点的具体属性<br>（待补完）<h3 id="关于具体的性能测试"><a href="#关于具体的性能测试" class="headerlink" title="关于具体的性能测试"></a>关于具体的性能测试</h3><a href="http://developit.github.io/js-repaint-perfs/" target="_blank" rel="external">REPAINT RATE CHALLENGE</a><br><a href="https://localvoid.github.io/uibench/" target="_blank" rel="external">UI Benchmark</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Preact/">Preact</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Virtual-DOM/">Virtual DOM</a></li></ul>

    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-GraphQL-Relay-first-explore"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/02/22/GraphQL-Relay-first-explore/">GraphQL+Relay初探</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/02/22/GraphQL-Relay-first-explore/" class="article-date">
	  <time datetime="2017-02-21T16:32:09.000Z" itemprop="datePublished">2017-02-22</time>
	</a>

      
    <a class="article-category-link" href="/categories/front-end/">front-end</a><a class="article-category-link" href="/categories/front-end/back-end/">back-end</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="GraphQL简介"><a href="#GraphQL简介" class="headerlink" title="GraphQL简介"></a>GraphQL简介</h3><p><img src="http://olu3hx27t.bkt.clouddn.com/image/graphql.png" alt=""><br>GraphQL是Facebook开源的一套用于API的查询语言和runtime，其比较明显的特色在于用一次请求拿到所有想要的数据，并且返回的查询结果与想要查询的格式一致。同时也强调了强类型，减少冗余。</p>
<h3 id="Query-Mutation"><a href="#Query-Mutation" class="headerlink" title="Query/Mutation"></a>Query/Mutation</h3><p>(后文大部分例子皆来自/魔改自官方文档)<br>拿一个如下的简单的query来分析，这里的hero，name或者friends叫做<code>field</code>，field会返回type中定义的类型。</p>
<ul>
<li>field能通过例如<code>hero(name: &quot;R2-D2&quot;)</code>这样的方式来添加参数</li>
<li>多个同级同类型的field能通过例如<code>empireHero: hero</code> 来指定别名</li>
<li>多个filed要查询相同类型的数据时，可以用碎片(fragments)来复用相同的查询条件</li>
<li>当遇到多个查询需要带上不同的参数时，可以使用变量 </li>
<li><p>可以用指令(directive)去动态的改变query的结构和形状，如<code>@include(if: Boolean)</code> <code>@skip(if: Boolean)</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">query Hero($episode: Episode, $withFriends: Boolean!) &#123;</div><div class="line">  hero(episode: $episode) &#123;</div><div class="line">    name</div><div class="line">    friends @include(if: $withFriends) &#123;</div><div class="line">      name</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>GraphQL不只是提供了获得数据的方式，也提供了Mutation去修改服务端的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) &#123;</div><div class="line">  createReview(episode: $ep, review: $review) &#123;</div><div class="line">    stars</div><div class="line">    commentary</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>GraphQL的schemas能定义接口和结合(union)的type，因此当query中的field在schema中对应这些type时，你需要内联碎片(inline fragments)去获取混合(concrete)type之下的数据。</p>
</li>
<li>当不知道服务器返回的type时，可以用meta field去代替,即在field前加上<code>__</code><br>例如 我们要查询带有’an’的数据，同时也不知道返回的数据的type，如果这个返回的数据的type是Droid，则会同时返回primaryFunction，如果为Human类型，则会返回height。此外返回结果里的__typename就会是这个查询结果的type的名字了(此例中可能为Human、Droid或者Starship)<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  search(text: &quot;an&quot;) &#123;</div><div class="line">    __typename</div><div class="line">    ... on Human &#123;</div><div class="line">      height</div><div class="line">    &#125;</div><div class="line">    ... on Droid &#123;</div><div class="line">      primaryFunction</div><div class="line">    &#125;</div><div class="line">    ... on Starship &#123;</div><div class="line">      name</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Types-Schemas"><a href="#Types-Schemas" class="headerlink" title="Types/Schemas"></a>Types/Schemas</h3><p>上一节中提到了许多次type，<code>type</code>即我们想要查询的field的类型，用于描述我们想要的数据。属于schema中最基础的一类</p>
<p>每一个<code>GarphQL Service</code>定义了一系列的type用于完全描述一系列可能会被查询到的数据。当query来的时候，GraphQL Service会根据schema去验证并执行。</p>
<p>GraphQL Service可以用<code>任何语言</code>去编写。同时还有一种叫做”GraphQL schema language”的语言用于描述schema。</p>
<p>一个简单的定义名为Character的type的例子</p>
<ul>
<li>name，appearsIn和length为该type的field</li>
<li>field的type后面的!表示该field不可为null</li>
<li>appearsIn: [Episode]表示对应这个appearsIn对应的是一个Episode类型的数据的数组</li>
<li>schema中的参数必须有名字，等号前的为参数的type，后面的为默认值</li>
<li><p>一些基本的type：<code>Int</code> <code>Float</code> <code>String</code> <code>Boolean</code> <code>ID</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">type Character &#123;</div><div class="line">    name: String!</div><div class="line">    appearsIn: [Episode]!</div><div class="line">    height(unit: LengthUnit = METER): Float</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>纯量(scalar)：经常作为query的叶结点，例如最前面的query例子里的name。可以用scalar去声明一个纯量 <code>scalar Date</code></p>
</li>
<li><p>枚举(enum)：枚举是一种特殊的纯量，他被限制为一个特定允许值的集合。这个特性可以拿来做验证或者利用一个有限集合的值来在type系统之间传送，可以用如下方式声明,Episode一定会为NEWHOPE、EMPIRE、和JEDI其中之一</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">enum Episode &#123;</div><div class="line">  NEWHOPE</div><div class="line">  EMPIRE</div><div class="line">  JEDI</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>接口(interface)：像许多强类型语言一样，GraphQL也提供了接口，即包含了type必须实现的、确定的、field的集合的抽象的type。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">interface Character &#123;</div><div class="line">  id: ID!</div><div class="line">  name: String!</div><div class="line">  friends: [Character]</div><div class="line">  appearsIn: [Episode]!</div><div class="line">&#125;</div><div class="line">type Human implements Character &#123;</div><div class="line">  id: ID!</div><div class="line">  name: String!</div><div class="line">  friends: [Character]</div><div class="line">  appearsIn: [Episode]!</div><div class="line">  starships: [Starship]</div><div class="line">  totalCredits: Int</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>结合(union)：结合和接口非常类似，只是没有具体说明type之间的共同field，即没有将type的具体属性抽象出来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">union SearchResult = Human | Droid | Starship</div></pre></td></tr></table></figure>
</li>
<li><p>输入(input)：当你可能要传递整个对象(例如参数为一个对象时)，需要指定这个对象的type，就可以使用input。简单的把type换成input即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">input ReviewInput &#123;</div><div class="line">  stars: Int!</div><div class="line">  commentary: String</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>上面就是GraphQL中一些基础概念，更加进阶的概念会在以后的文章中提到。</p>
<h3 id="GraphQL对比RESTful"><a href="#GraphQL对比RESTful" class="headerlink" title="GraphQL对比RESTful"></a>GraphQL对比RESTful</h3><p>一万个人心中有一万种RESTful，RESTful虽然简单易理解，但是在深入开发的过程中其难扩展的缺点逐渐暴露了出来。</p>
<p>例如前面官网上的例子，GraphQL会直接返回这样的结果<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"data"</span>: &#123;</div><div class="line">        <span class="attr">"hero"</span>: &#123;</div><div class="line">            <span class="attr">"name"</span>: <span class="string">"Luke Skywalker"</span></div><div class="line">            <span class="string">"friends"</span>: [</div><div class="line">                &#123; <span class="attr">"name"</span>: <span class="string">"Han Solo"</span> &#125;,</div><div class="line">                &#123; <span class="attr">"name"</span>: <span class="string">"R2-D2"</span> &#125;,</div><div class="line">                &#123; <span class="attr">"name"</span>: <span class="string">"Leia Organa"</span> &#125;,</div><div class="line">            ]</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而RESTful，可能有人会这样写<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">GET /hero/ </div><div class="line">#之后遍历返回的信息，并发送新请求</div><div class="line">GET /hero/加上前一次查询返回的name/friends/</div></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /heros?extend_query=friends</div></pre></td></tr></table></figure></p>
<p>这种情景下，RESTful可能会去发送多次请求，或者把请求魔改得不直观。GraphQL恰恰能很好的解决这类问题。</p>
<p>同时我们也看到了，GraphQL在一定程度上，查询请求是不依赖url的，这也许意味着当系统要添加新的功能，同时需要的数据能用之前的数据组装，就不需要新的后台接口了。</p>
<p>此外，若是后台能将数据拆分，提供大量的原子数据接口的话，那么对于产品版本迅速迭代将是一件非常有意义的事情。</p>
<h3 id="Relay简介"><a href="#Relay简介" class="headerlink" title="Relay简介"></a>Relay简介</h3><p><img src="http://olu3hx27t.bkt.clouddn.com/image/relay.png" alt=""><br>Relay是一个用于构建数据驱动的React应用的框架，结合GraphQL可以实现用GraphQL声明需要的数据，Relay指明在什么时机用什么方法去获取数据。<br>Relay还能综合所有query，利用高效的网络请求去获取你恰好需要的数据，也能结合GraphQL的mutation去修改客户端/服务端上的数据，并且同时提供了自动化的连贯的数据更新机制和错误处理机制。</p>

      
    </div>
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GraphQL/">GraphQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Relay/">Relay</a></li></ul>

    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-vue-directive-to-highlight-code"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2016/09/10/vue-directive-to-highlight-code/">vue自定义指令实现Highlight.js高亮代码</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2016/09/10/vue-directive-to-highlight-code/" class="article-date">
	  <time datetime="2016-09-10T14:58:05.000Z" itemprop="datePublished">2016-09-10</time>
	</a>

      
    <a class="article-category-link" href="/categories/front-end/">front-end</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>在Vue项目中直接引入highlight.js会遇到一些问题，<a href="https://forum.vuejs.org/topic/3514/getting-highlightjs-to-work-with-vue-router" target="_blank" rel="external">官方论坛</a>上的一篇帖子给出了出现这种现象的原因，即vue-router在改变路由的时候会清除渲染,并移除事件<br>参考了答案后，得出了用vue的自定义指令(directive)解决问题的方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> hljs <span class="keyword">from</span> <span class="string">'highlight.js'</span></div><div class="line"><span class="comment">//还需要引入hljs的主题css，此处略过</span></div><div class="line">Vue.directive(<span class="string">'highlight'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> blocks = <span class="keyword">this</span>.el.querySelectorAll(<span class="string">'pre code'</span>)</div><div class="line">    <span class="built_in">Array</span>.prototype.forEach.call(blocks, hljs.highlightBlock)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>补充：Vue 2中，自定义指令的API发生了一些变化，需要用这样的写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Vue.directive(<span class="string">'highlight'</span>, &#123;</div><div class="line">    <span class="attr">bind</span>: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</div><div class="line">        <span class="keyword">let</span> blocks = <span class="keyword">this</span>.el.querySelectorAll(<span class="string">'pre code'</span>)</div><div class="line">        <span class="built_in">Array</span>.prototype.forEach.call(blocks, hljs.highlightBlock)</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>设置好自定义指令后，在标签里使用指令<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-highlight</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">pre</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">code</span> <span class="attr">class</span>=<span class="string">'可以在这里手动指定语言'</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">code</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>补充2: 利用上面的原理，我写了一个简单的插件<a href="https://github.com/SunskyXH/vue-hljs" target="_blank" rel="external">vue-hljs</a>，安装完并引入依赖以后，简单的<code>Vue.use(vueHljs)</code>就可以使用v-highlight去高亮代码了。</p>

      
    </div>
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/">Vue</a></li></ul>

    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-The-State-of-Vue"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2016/08/20/The-State-of-Vue/">The State of Vue(自译)</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2016/08/20/The-State-of-Vue/" class="article-date">
	  <time datetime="2016-08-20T15:11:09.000Z" itemprop="datePublished">2016-08-20</time>
	</a>

      
    <a class="article-category-link" href="/categories/front-end/">front-end</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<h3 id="2-0-is-now-in-RC"><a href="#2-0-is-now-in-RC" class="headerlink" title="2.0 is now in RC!"></a>2.0 is now in RC!</h3><p>We announced Vue 2.0 back in April,<br>and today I am very excited to release the first release candidate for Vue 2.0!<br>From this stage on we will be in API freeze and there will be no more breaking changes before official release.</p>
</blockquote>
<h3 id="2-0-正在候选发布-RC-！"><a href="#2-0-正在候选发布-RC-！" class="headerlink" title="2.0 正在候选发布(RC)！"></a>2.0 正在候选发布(RC)！</h3><p>我们在四月的时候宣布了<a href="https://medium.com/the-vue-point/announcing-vue-js-2-0-8af1bde7ab9" target="_blank" rel="external">Vue 2.0的消息</a>,<br>并且在今天我将非常激动地发布<a href="https://github.com/vuejs/vue/releases/tag/v2.0.0-rc.1" target="_blank" rel="external">Vue 2.0的第一个RC版本！</a><br>从这个阶段起我们将会API冻结,并且在官方版本之前将会有更多突破性的改动.<br><br></p>
<blockquote>
<p>All the official supporting libraries, e.g. vue-router, vuex, vue-loader &amp; vueify have all been updated to work with Vue 2.0.<br>This means the 2.0 stack is technically complete — the only thing we are waiting for is documentation and release-related logistics.<br>Despite that, we have prepared a Vue 2.0 RC Starter Resources guide to help those feeling adventurous jump right into 2.0 today.</p>
</blockquote>
<p>所有官方支持的库，例如vue-router,vuex,vue-loader和vueify都已经升级到能和Vue 2.0一起使用。<br>这意味着2.0在技术层面已经完善——我们唯一在等待的就是文档和发布相关的后续工作<br>尽管如此，我们准备了<a href="https://github.com/vuejs/vue/wiki/Vue-2.0-RC-Starter-Resources" target="_blank" rel="external">Vue 2.0 RC Starter Resources</a><br>指南来帮助那些想要探险的人跳入2.0的大坑。<br><br></p>
<blockquote>
<h3 id="Vue-js-in-the-Industry"><a href="#Vue-js-in-the-Industry" class="headerlink" title="Vue.js in the Industry"></a>Vue.js in the Industry</h3><p>I recently answered the question “How Popular is Vue.js in the Industry?” on Quora.<br>You can read about the full answer here, but here are some highlights:</p>
<ul>
<li>Based on the combined metrics including Google Trends, GitHub star history &amp; stats.js.org statistics,<br>Vue.js has consistently been one of the fastest growing libraries in the past few months and there’s currently no sign of slowing down.</li>
<li>1 million+ downloads on NPM at 125k~150k per month<br></li>
<li>1.5 million page views &amp; 150k monthly unique visitors on vuejs.org<br></li>
<li>36,000+ weekly active vue-devtool users<br></li>
<li>Used by great open source projects: Laravel, GitLab, PageKit &amp; more.<br></li>
<li>Strong international adoption: biggest Chinese public companies (Alibaba, Baidu, Tencent), biggest Chinese unicorns (private companies with $1B+ valuation — Xiaomi, Didi Chuxing, DJI, Ele.me), established enterprises in Japan/UK (Line, Nintendo, Sainsbury’s)</li>
</ul>
</blockquote>
<h3 id="业界的Vue-js"><a href="#业界的Vue-js" class="headerlink" title="业界的Vue.js"></a>业界的Vue.js</h3><p>我最近在Quora上回答了“Vue在业界有多流行?”的问题. 你可以在这里看到全部的答案, 当然你也可以只看以下几点:</p>
<ul>
<li>根据结合了包括 Google Trends, Github star历史记录以及 stats.js.org统计数据在内的度量结果, Vue.js在过去几个月内连续保持增长最快速的库之一,并且现在毫无减弱的迹象.</li>
<li>NPM上有100万次以上的下载, 每月12.5到15万.</li>
<li>vuejs.org访问量达150万, 每月有15万不同的访客.</li>
<li>vue-devtool 每月有36万以上的活跃用户.</li>
<li>被大型开源项目所用：例如 Laravel, GitLab, PageKit 等等.</li>
<li>国际上广为采用: 例如 中国最大的公司(阿里巴巴,腾讯,百度),中国最大的独角兽公司(具有一亿以上资产的私有公司——小米,滴滴出行,大疆,饿了么),设立在日本/英国的企业(Line,任天堂,森宝利)<br></li>
</ul>
<blockquote>
<h3 id="Patreon-Campaign-Going-Strong"><a href="#Patreon-Campaign-Going-Strong" class="headerlink" title="Patreon Campaign Going Strong"></a>Patreon Campaign Going Strong</h3><p>The Vue.js patreon campign now has over $8,000 monthly pledge from the community and sponsors.<br>It is absolutely amazing to be able to work full-time on an open source project that I am genuinely passionate about, and for that I am forever grateful to all the supporters.<br></p>
<h3 id="Patreon-Campaign-让我们更加壮大"><a href="#Patreon-Campaign-让我们更加壮大" class="headerlink" title="Patreon Campaign 让我们更加壮大"></a>Patreon Campaign 让我们更加壮大</h3><p>Vue.js patreon campign现在已经有了每月从社区和赞助者处得到的$8,000的赞助.<br>能全职投入到一个我真正为之狂热的开源项目中当然是令人惊讶的, 因此我永远感谢那些支持我的人.<br>I think the Vue.js patreon campaign is an interesting experiment on sustainable financial models for open source projects that demand serious commitment: it’s open source not as the by-product of a commercial company trying to help with recruiting — the only goal of the project is to create something that help more people get more things done in an easier and faster way. It’s sustained not by revenue that possibly has nothing to do with the project itself, but rather directly by those who use it in their everyday work. To be honest, I don’t think this is a model that is easy to pull off (for that I am very lucky), but I do hope it can serve as a valuable case study for those who are interested in more sustainable open source work.</p>
</blockquote>
<p>我认为Vue.js patreon campign 是一个对需要严肃承诺的开源项目的可持续金融模型上有趣的实验: 它不是因为作为商业公司用来招聘的副产品而开源——这个项目的唯一目标就是创造一些能够帮助更多的人用更简单快捷的方法做更多事情的东西. 它可持续不是因为那些可能对项目本身无益的收入,而是直接因为那些每天都在工作中都在用到它的人.讲真, 我不认为这是一个能轻松推广的模型(所以说我很幸运), 但我衷心希望它能够作为一个对致力于更加可持续开源项目的人来说有价值的案例而服务.</p>

      
    </div>
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/">Vue</a></li></ul>

    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-i-dont-know-js"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2016/07/30/i-dont-know-js/">我不懂的js集合</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2016/07/30/i-dont-know-js/" class="article-date">
	  <time datetime="2016-07-30T12:57:55.000Z" itemprop="datePublished">2016-07-30</time>
	</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>（一些技巧和思考）</p>

      
    </div>
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>

    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  


</section>
        
      </div>
      
        <div align="center" style="margin-top: 30px;"><hr class="hr" style="margin:0px; height:3px;"></div>
      
      <footer id="footer">
  

  <div class="container">
      <div class="row">
	      <p> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/iTimeTraveler/hexo-theme-hiker" target="_blank">Hexo-theme-hiker</a> </p>
	      <p id="copyRightEn">Copyright &copy; 2013 - 2017 Bonfire All Rights Reserved.</p>
	      <p id="copyRightCn">SunskyXH hold copyright</p>
	</div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");
    var allheader = document.getElementById("allheader");

    wrapdiv.style.minHeight = document.body.offsetHeight + "px";
    if (allheader != null) {
      contentdiv.style.minHeight = document.body.offsetHeight - allheader.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    } else {
      contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    }
</script>
    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>


  <script src="/js/home.js"></script>





<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-92411339-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->




  </div>

  <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true" style="display: none;">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title" id="myModalLabel">设置</h2>
      </div>
      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">


      <div class="modal-body">
          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseOne" onclick="javascript:setFontSize();" aria-expanded="true" aria-controls="collapseOne">
              正文字号大小
            </a>
          </div>
          <div id="collapseOne" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOne">
          <div class="panel-body">
            您已调整页面字体大小
          </div>
        </div>
      


          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseTwo" onclick="javascript:setBackground();" aria-expanded="true" aria-controls="collapseTwo">
              夜间护眼模式
            </a>
        </div>
          <div id="collapseTwo" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
          <div class="panel-body">
            夜间模式已经开启，再次单击按钮即可关闭 
          </div>
        </div>

        <div>
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseThree" aria-expanded="true" aria-controls="collapseThree">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关 于&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
        </div>
         <div id="collapseThree" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingThree">
          <div class="panel-body">
            Bonfire
          </div>
          <div class="panel-body">
            Copyright © 2017 SunskyXH All Rights Reserved.
          </div>
        </div>
      </div>


      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <div class="modal-footer">
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
      </div>
    </div>
  </div>
</div>
  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
  

	<div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>


</body>
</html>