<!DOCTYPE html>
<html lang=en,zh-cn,default>
  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="description" content="这里什么都没有">
  <meta name="keywords" content="undefined">
  
    <link rel="icon" href="">
  
  <title>有必要将Vue项目重构到Typescript吗?</title>
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/atom-one-light.css">
<link rel="stylesheet" href="/css/font-awesome.min.css">
  <script src="/js/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body>
  <div class="wrapper">
    <div class="default_title">
        <img src="/imgs/mycomputer.png" />
        <h1>香香鸡的小窝</h1>
    </div>
    <ul class="topbar">
    
        <li>
        <a href="/" class="item-link">首页</a>
        </li>
    
        <li>
        <a href="/about" class="item-link">关于</a>
        </li>
    
    </ul>
    <div class="tag_list">
    <ul id="tag-list">
        <li><a href="/" ><img src="/imgs/disk.png" />(C:)</a>
        <ul>
        
            <li>
            <a href="/tags/javascript" title="javascript" rel="3">
                <img src="/imgs/folder.ico" />
                javascript
            </a>
            </li>    
        
            <li>
            <a href="/tags/GraphQL" title="GraphQL" rel="1">
                <img src="/imgs/folder.ico" />
                GraphQL
            </a>
            </li>    
        
            <li>
            <a href="/tags/Relay" title="Relay" rel="1">
                <img src="/imgs/folder.ico" />
                Relay
            </a>
            </li>    
        
            <li>
            <a href="/tags/Vue" title="Vue" rel="3">
                <img src="/imgs/folder.ico" />
                Vue
            </a>
            </li>    
        
            <li>
            <a href="/tags/Typescript" title="Typescript" rel="1">
                <img src="/imgs/folder.ico" />
                Typescript
            </a>
            </li>    
        
            <li>
            <a href="/tags/React" title="React" rel="1">
                <img src="/imgs/folder.ico" />
                React
            </a>
            </li>    
        
            <li>
            <a href="/tags/Preact" title="Preact" rel="1">
                <img src="/imgs/folder.ico" />
                Preact
            </a>
            </li>    
        
            <li>
            <a href="/tags/Virtual DOM" title="Virtual DOM" rel="1">
                <img src="/imgs/folder.ico" />
                Virtual DOM
            </a>
            </li>    
        
            <li>
            <a href="/tags/redux-saga" title="redux-saga" rel="1">
                <img src="/imgs/folder.ico" />
                redux-saga
            </a>
            </li>    
        
            <li>
            <a href="/tags/redux-observable" title="redux-observable" rel="1">
                <img src="/imgs/folder.ico" />
                redux-observable
            </a>
            </li>    
        
            <li>
            <a href="/tags/Reason" title="Reason" rel="1">
                <img src="/imgs/folder.ico" />
                Reason
            </a>
            </li>    
        
            <li>
            <a href="/tags/OCaml" title="OCaml" rel="1">
                <img src="/imgs/folder.ico" />
                OCaml
            </a>
            </li>    
        
            <li>
            <a href="/tags/bucklescript" title="bucklescript" rel="1">
                <img src="/imgs/folder.ico" />
                bucklescript
            </a>
            </li>    
        
        </ul>
    </ul>
    </div>
    <div class="post_list">
    <ul>
        
            <li>
            <a href="/2017/04/05/6-reasons-why-javascripts-async-await-blows-promises-away/">
            <img src="/imgs/file.ico" />
                Async/Await胜过Promise的6个理由（自译）
            </a>
            </li>
        
            <li>
            <a href="/2017/02/22/GraphQL-Relay-first-explore/">
            <img src="/imgs/file.ico" />
                GraphQL+Relay初探
            </a>
            </li>
        
            <li>
            <a href="/2016/08/20/The-State-of-Vue/">
            <img src="/imgs/file.ico" />
                The State of Vue(自译)
            </a>
            </li>
        
            <li>
            <a href="/2018/03/12/dose-refactoring-vue-project-into-typescript-deserved/">
            <img src="/imgs/file.ico" />
                有必要将Vue项目重构到Typescript吗?
            </a>
            </li>
        
            <li>
            <a href="/2017/02/26/preact-virtual-DOM-algorithm-explore/">
            <img src="/imgs/file.ico" />
                Preact Virtual DOM算法探究
            </a>
            </li>
        
            <li>
            <a href="/2017/03/30/i-dont-know-js/">
            <img src="/imgs/file.ico" />
                我不懂的js集合
            </a>
            </li>
        
            <li>
            <a href="/2017/12/17/reason-intro/">
            <img src="/imgs/file.ico" />
                Reason简介
            </a>
            </li>
        
            <li>
            <a href="/2016/09/10/vue-directive-to-highlight-code/">
            <img src="/imgs/file.ico" />
                vue自定义指令实现Highlight.js高亮代码
            </a>
            </li>
        
    </ul>
    </div>

    <div class="post_total">
        
            <div class="left">8 object(s)</div>
        
        <div class="right">&nbsp;</div>
    </div>
</div>
  <div class="content">
    <div class="post_title">
      <img src="/imgs/file.png" />
      <h1>有必要将Vue项目重构到Typescript吗?</h1>
      <a href="/"><div class="btn"><span class="fa fa-times"></span></div></a>
      <div class="btn btn_max"><span class="fa fa-window-maximize"></span></div>
      <div class="btn"><span class="fa fa-window-minimize"></span></div>
    </div>
    <ul class="topbar">
      <li>Mon Mar 12 2018 21:20:34 GMT+0800</li>
    </ul>
    <div class="post_content">
      <h2 id="Vue对Typescript的支持"><a href="#Vue对Typescript的支持" class="headerlink" title="Vue对Typescript的支持"></a>Vue对Typescript的支持</h2><p>与React不同的是，Vue的组件在运行时是动态生成的，换句话说就是在非runtime环境是无法知道具体变量的类型的，而React尤其是使用了ES6class作为组件的React在做静态类型检查的时候会有天生的优势，也就是这个原因导致tsx的支持非常的迅速。<br>虽然Vue在2.5.0版本中为<code>Vue</code>，<code>vue-route</code>和<code>vuex</code>等库加入了大量的type declarations，但是Typescript依然无法轻易的推断出Vue中用到的基于对象的Api中的<code>this</code>，换个通俗点的说法就是以前用Typescript难以推断用Object的写法写出的Vue组件中的<code>this</code>。</p>
<h2 id="vue-class-component"><a href="#vue-class-component" class="headerlink" title="vue-class-component"></a>vue-class-component</h2><p>为了解决这个问题，Vue官方推出了一个名为<code>vue-class-component</code>的库，该库提供了一个名为Component的装饰器，目的在于能让开发者用class的语法去写Vue组件。<br>大致会发生如下改变</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 改造前</span></div><div class="line">&lt;script&gt;</div><div class="line"><span class="keyword">import</span> someComponent from <span class="string">'path/to/component'</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    props: &#123; propsA: &#123; <span class="keyword">type</span>: <span class="built_in">String</span>, required: <span class="literal">true</span> &#125; &#125;,</div><div class="line">    component: &#123; someComponent &#125;,</div><div class="line">    data() &#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            dataA: <span class="string">''</span>,</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    computed &#123;</div><div class="line">        computedA() &#123; <span class="keyword">return</span> <span class="keyword">this</span>.dataA + <span class="string">'wahaha'</span> &#125;</div><div class="line">    &#125;</div><div class="line">    methods: &#123;</div><div class="line">        foo () &#123;</div><div class="line">            alert(<span class="keyword">this</span>.dataA)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    mounted () &#123;</div><div class="line">        <span class="keyword">this</span>.foo()</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 改造后</span></div><div class="line">&lt;script lang=<span class="string">'ts'</span>&gt;</div><div class="line"><span class="keyword">import</span> SomeComponent from <span class="string">'path/to/component'</span></div><div class="line"><span class="keyword">import</span> Vue from <span class="string">'vue'</span></div><div class="line"><span class="keyword">import</span> Component from <span class="string">'vue-class-component'</span></div><div class="line"></div><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">    props: &#123; propsA: &#123; <span class="keyword">type</span>: <span class="built_in">String</span>, required: <span class="literal">true</span> &#125; &#125;,</div><div class="line">    component: &#123; someComponent &#125;</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> Foo extends Vue &#123;</div><div class="line">    propMessage!: <span class="built_in">string</span></div><div class="line">    dataA: <span class="built_in">string</span> = <span class="string">''</span></div><div class="line">    <span class="keyword">get</span> computedA(): <span class="built_in">string</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>.dataA + <span class="string">'wahaha'</span> &#125;</div><div class="line">    foo () &#123;</div><div class="line">        alert(<span class="keyword">this</span>.dataA)</div><div class="line">    &#125;</div><div class="line">    mounted () &#123;</div><div class="line">        <span class="keyword">this</span>.foo()</div><div class="line">    &#125;</div><div class="line">    $refs!: &#123;</div><div class="line">        SomeComponent: SomeComponent</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<p>看起来是不是很熟悉很简单，但是实际上不是这样的，从官方的例子我们能看出该库有了如下改变规则</p>
<ul>
<li>将class的成员方法直接作为组件的methods</li>
<li>与生命周期钩子同名的成员方法将作为生命周期函数</li>
<li>组件内部成员变量作为响应式数据，同时可以声明类型</li>
<li>计算属性改为get属性</li>
<li>使用了$refs占位符的动态组件，需要声明类型</li>
<li>props也需要声明类型</li>
</ul>
<p>如果仔细一点，你会发现，我的props在两个地方被声明了类型。不难看出，作为装饰器的参数的props其实是vue组件本身自带的类型检查，而在class内部声明的类型，是交给typescript做类型检查的。<br>这意味着，我们在重构代码时需要做一些抉择：究竟是否放弃Vue本身的类型检查。</p>
<p>同时，vue组件的选项远不止上述代码展示的这么点，<code>vue-class-component</code>的官方文档中这样写道：</p>
<blockquote>
<p>For all other options, pass them to the decorator function.</p>
</blockquote>
<p>刚看到这里的时候我以为官方已经为开发者做好了一切，然而在继续翻阅文档和源码的过程中我发现并非这样，官方提供了一种自己<code>createDecorator</code>的方法，也就是自己动手的意思。<br>好在有一个名为<code>vue-property-decorator</code>的库已经在<code>vue-class-component</code>的基础上封装了常用的vue组件选项，这个将在下文中讨论。</p>
<p>当然也有人会好奇，用新的类的写法，能否像react一样将类的方法写成箭头函数的形式呢。很遗憾依然不行，箭头函数中的this依然没有指向vue实例，这意味着在箭头函数内部使用this.dataName这种方式来修改响应式数据是不会生效的。</p>
<h2 id="vue-property-decorator"><a href="#vue-property-decorator" class="headerlink" title="vue-property-decorator"></a>vue-property-decorator</h2><p><a href="https://github.com/kaorun343/vue-property-decorator" target="_blank" rel="external">vue-property-decorator</a> 为开发者提供了7中装饰器，他们分别是</p>
<ul>
<li><code>@Emit</code></li>
<li><code>@Inject</code></li>
<li><code>@Model</code></li>
<li><code>@Prop</code></li>
<li><code>@Provide</code></li>
<li><code>@Watch</code></li>
<li><code>@Component</code></li>
</ul>
<p>体验了一番下来，让我最感到奇怪的是<code>@Emit</code>这个装饰器，例如我原本要emit一个click事件</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 按照原本vue的写法</span></div><div class="line">onFooClick(foo) &#123;</div><div class="line">    <span class="keyword">this</span>.$emit(<span class="string">'click'</span>, foo)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 使用了装饰器后</span></div><div class="line"><span class="comment">// onFooClick的参数foo 是$emit的第二个参数</span></div><div class="line"><span class="meta">@Emit</span>(<span class="string">'click'</span>)</div><div class="line">onFooClick(foo: <span class="built_in">any</span>) &#123;&#125;</div></pre></td></tr></table></figure>
<p>但是如果foo的来源其实是组件内部的响应式数据，原本的写法只需要将参数去掉，$emit的第二个参数改为<code>this.foo</code>，即：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 按照原本vue的写法</span></div><div class="line">onFooClick() &#123;</div><div class="line">    <span class="keyword">this</span>.$emit(<span class="string">'click'</span>, <span class="keyword">this</span>.foo)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 使用了装饰器后</span></div><div class="line"><span class="comment">// 需要在调用onFooClick的地方将this.foo作为参数传给onFooClick</span></div><div class="line"><span class="meta">@Emit</span>(<span class="string">'click'</span>)</div><div class="line">onFooClick(foo: <span class="built_in">any</span>) &#123;&#125;</div></pre></td></tr></table></figure>
<p>并且，<code>@Prop</code>这个装饰器并没有解决Vue自带的类型检查和typescript类型检查的矛盾，该装饰器依然可以接受vue类型的写法。<br>这意味着如果你想进行静态类型检查+运行时的类型检查，需要写两套规则不太一样的类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Prop</span>([<span class="built_in">String</span>, <span class="built_in">Boolean</span>])</div><div class="line">someProp: <span class="built_in">string</span> | <span class="built_in">boolean</span></div></pre></td></tr></table></figure>
<h2 id="Declaration"><a href="#Declaration" class="headerlink" title="Declaration"></a>Declaration</h2><p>Vue有不少插件会在Vue实例下面挂在新的方法，而官方提供的Vue类型生命中是肯定没有这些方法的，为了解决这个问题，Vue官方推荐使用module augmentation来帮助Vue补充新的类型声明。<br><del>从工程上看，这个举动确实能帮助类型检查，但是回到现实情况中，一般我们会在项目的入口文件中给vue注入挂载各种插件（即在<code>index.js</code>或者<code>main.js</code>之类的入口文件调用<code>Vue.use()</code>），基本不会存在调用的时候Vue没有挂载该方法的情况，然而Vue下挂载属性一般是将其用作全局状态来使用的，同时vue也提供vuex这样的全局状态管理库，直接把状态挂载vue实例下的情况并不多见，再加上如果是服务端渲染的项目，这类side effect更应该交由vuex来管理。不过话说回来，防范于未然总是好的。</del><br>上面这句话不一定正确，先划掉。</p>
<h2 id="Reactive"><a href="#Reactive" class="headerlink" title="Reactive"></a>Reactive</h2><p>响应式的数据是vue的特色之一，但是也导致了使用了响应式数据的计算属性/方法无法有typescript来推断类型，需要自己手动标注。不能使用类型推断而需要自己一个个手动标注，如果是比较大的项目，很有可能出现很多变量都是<code>any</code>类型（是的我就喜欢这样干），那这样引入ts也就毫无意义了</p>
<h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><p>随着vue版本更新，vue项目也能ts带来的诸多好处，但是并不是每一个团队都能在紧张刺激的产品迭代期间挤出时间进行这样的重构。相比这些好处，重构的工程量究竟会有多大，是否真的有必要这样做是一个值得思考的问题。</p>

    </div>
</div>
  <footer class="footer">
  <p> powered by hexo</p>
</footer>
<script>
  var max = document.getElementsByClassName("btn")[1];
  var min = document.getElementsByClassName("btn")[2];

  function maximize () {
    var post = document.getElementsByClassName("content")[0];
    var cont = document.getElementsByClassName("post_content")[0];
    var wid = window.innerWidth || document.documentElement.clientWidth || document.getElementsByTagName("body")[0].clientWidth;

    if (wid > 900) {
      widf = wid * 0.9;
      post.style.width = widf + "px";

      if (wid < 1400) {
        cont.style.width = "99%";
      } else {
        cont.style.width = "99.4%";
      }
    }
  }

  function minimize () {
    var post = document.getElementsByClassName("content")[0];
    var cont = document.getElementsByClassName("post_content")[0];
    var wid = window.innerWidth || document.documentElement.clientWidth || document.getElementsByTagName("body")[0].clientWidth;

    if ( wid > 900 ) {
      post.style.width = "800px";
      cont.style.width = "98.5%";
    }
  }

  max && max.addEventListener('click', maximize, false);
  min && min.addEventListener('click', minimize, false);

</script>
</body>
</html>