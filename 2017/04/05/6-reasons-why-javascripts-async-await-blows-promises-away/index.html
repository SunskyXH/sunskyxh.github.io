<!DOCTYPE html>
<html lang=en,zh-cn,default>
  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="description" content="这里什么都没有">
  <meta name="keywords" content="undefined">
  
    <link rel="icon" href="">
  
  <title>Async/Await胜过Promise的6个理由（自译）</title>
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/atom-one-light.css">
<link rel="stylesheet" href="/css/font-awesome.min.css">
  <script src="/js/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body>
  <div class="wrapper">
    <div class="default_title">
        <img src="/imgs/mycomputer.png" />
        <h1>香香鸡的小窝</h1>
    </div>
    <ul class="topbar">
    
        <li>
        <a href="/" class="item-link">首页</a>
        </li>
    
        <li>
        <a href="/about" class="item-link">关于</a>
        </li>
    
    </ul>
    <div class="tag_list">
    <ul id="tag-list">
        <li><a href="/" ><img src="/imgs/disk.png" />(C:)</a>
        <ul>
        
            <li>
            <a href="/tags/javascript" title="javascript" rel="3">
                <img src="/imgs/folder.ico" />
                javascript
            </a>
            </li>    
        
            <li>
            <a href="/tags/GraphQL" title="GraphQL" rel="1">
                <img src="/imgs/folder.ico" />
                GraphQL
            </a>
            </li>    
        
            <li>
            <a href="/tags/Relay" title="Relay" rel="1">
                <img src="/imgs/folder.ico" />
                Relay
            </a>
            </li>    
        
            <li>
            <a href="/tags/Vue" title="Vue" rel="3">
                <img src="/imgs/folder.ico" />
                Vue
            </a>
            </li>    
        
            <li>
            <a href="/tags/Typescript" title="Typescript" rel="1">
                <img src="/imgs/folder.ico" />
                Typescript
            </a>
            </li>    
        
            <li>
            <a href="/tags/React" title="React" rel="1">
                <img src="/imgs/folder.ico" />
                React
            </a>
            </li>    
        
            <li>
            <a href="/tags/Preact" title="Preact" rel="1">
                <img src="/imgs/folder.ico" />
                Preact
            </a>
            </li>    
        
            <li>
            <a href="/tags/Virtual DOM" title="Virtual DOM" rel="1">
                <img src="/imgs/folder.ico" />
                Virtual DOM
            </a>
            </li>    
        
            <li>
            <a href="/tags/redux-saga" title="redux-saga" rel="1">
                <img src="/imgs/folder.ico" />
                redux-saga
            </a>
            </li>    
        
            <li>
            <a href="/tags/redux-observable" title="redux-observable" rel="1">
                <img src="/imgs/folder.ico" />
                redux-observable
            </a>
            </li>    
        
            <li>
            <a href="/tags/Reason" title="Reason" rel="1">
                <img src="/imgs/folder.ico" />
                Reason
            </a>
            </li>    
        
            <li>
            <a href="/tags/OCaml" title="OCaml" rel="1">
                <img src="/imgs/folder.ico" />
                OCaml
            </a>
            </li>    
        
            <li>
            <a href="/tags/bucklescript" title="bucklescript" rel="1">
                <img src="/imgs/folder.ico" />
                bucklescript
            </a>
            </li>    
        
        </ul>
    </ul>
    </div>
    <div class="post_list">
    <ul>
        
            <li>
            <a href="/2017/04/05/6-reasons-why-javascripts-async-await-blows-promises-away/">
            <img src="/imgs/file.ico" />
                Async/Await胜过Promise的6个理由（自译）
            </a>
            </li>
        
            <li>
            <a href="/2017/02/22/GraphQL-Relay-first-explore/">
            <img src="/imgs/file.ico" />
                GraphQL+Relay初探
            </a>
            </li>
        
            <li>
            <a href="/2016/08/20/The-State-of-Vue/">
            <img src="/imgs/file.ico" />
                The State of Vue(自译)
            </a>
            </li>
        
            <li>
            <a href="/2018/03/12/dose-refactoring-vue-project-into-typescript-deserved/">
            <img src="/imgs/file.ico" />
                有必要将Vue项目重构到Typescript吗?
            </a>
            </li>
        
            <li>
            <a href="/2017/02/26/preact-virtual-DOM-algorithm-explore/">
            <img src="/imgs/file.ico" />
                Preact Virtual DOM算法探究
            </a>
            </li>
        
            <li>
            <a href="/2017/03/30/i-dont-know-js/">
            <img src="/imgs/file.ico" />
                我不懂的js集合
            </a>
            </li>
        
            <li>
            <a href="/2017/12/17/reason-intro/">
            <img src="/imgs/file.ico" />
                Reason简介
            </a>
            </li>
        
            <li>
            <a href="/2016/09/10/vue-directive-to-highlight-code/">
            <img src="/imgs/file.ico" />
                vue自定义指令实现Highlight.js高亮代码
            </a>
            </li>
        
    </ul>
    </div>

    <div class="post_total">
        
            <div class="left">8 object(s)</div>
        
        <div class="right">&nbsp;</div>
    </div>
</div>
  <div class="content">
    <div class="post_title">
      <img src="/imgs/file.png" />
      <h1>Async/Await胜过Promise的6个理由（自译）</h1>
      <a href="/"><div class="btn"><span class="fa fa-times"></span></div></a>
      <div class="btn btn_max"><span class="fa fa-window-maximize"></span></div>
      <div class="btn"><span class="fa fa-window-minimize"></span></div>
    </div>
    <ul class="topbar">
      <li>Wed Apr 05 2017 01:28:56 GMT+0800</li>
    </ul>
    <div class="post_content">
      <p><a href="https://hackernoon.com/6-reasons-why-javascripts-async-await-blows-promises-away-tutorial-c7ec10518dd9" target="_blank" rel="external">原文链接</a></p>
<blockquote>
<p>In case you missed it, Node now supports async/await out of the box since version 7.6. If you haven’t tried it yet, here are a bunch of reasons with examples why you should adopt it immediately and never look back.</p>
</blockquote>
<p>如果你错过了它，Node7.6现在已经支持async/await。如果你至今还没有试过，本文将会有许多理由和例子来告诉你为什么你应该马上使用async/await并且再也不回换回之前的写法。</p>
<blockquote>
<p>Async/await 101<br>For those who have never heard of this topic before, here’s a quick intro</p>
<ul>
<li>Async/await is a new way to write asynchronous code. Previous options for asynchronous code are callbacks and promises.</li>
<li>Async/await is actually built on top of promises. It cannot be used with plain callbacks or node callbacks.</li>
<li>Async/await is, like promises, non blocking.</li>
<li>Async/await makes asynchronous code look and behave a little more like synchronous code. This is where all its power lies.</li>
</ul>
</blockquote>
<h3 id="Async-await基础"><a href="#Async-await基础" class="headerlink" title="Async/await基础"></a>Async/await基础</h3><p>这里给没有从没用过async/await的读者进行一个简单的介绍</p>
<ul>
<li>async/await是一种书写异步代码的新方法，在这之前使用回调函数和promise来设置异步代码。</li>
<li>async/await实际上是在promise的基础上构建的，他不能和纯回调函数(plain callbacks)和节点回调函数(node callbacks)一起使用。</li>
<li>async/await很像promise，是非阻塞的。</li>
<li>async/await让异步代码的外观和行为像同步代码。这就是他厉害的地方。</li>
</ul>
<blockquote>
<p>Syntax<br>Assuming a function getJSON that returns a promise, and that promise resolves with some JSON object. We just want to call it and log that JSON, then return “done”.<br>This is how you would implement it using promises</p>
</blockquote>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>假设一个函数<code>getJSON</code>返回一个promise，并且该promise会去reslove一些JSON对象，我们只是像简单的调用它并且打印该JSON，之后再返回<code>&quot;done&quot;</code>。</p>
<p>你可能用promise这样去实现<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> makeRequest= <span class="function"><span class="params">()</span> =&gt;</span></div><div class="line">  getJSON()</div><div class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</div><div class="line">      <span class="built_in">console</span>.log(data)</div><div class="line">      <span class="keyword">return</span> <span class="string">"done"</span></div><div class="line">    &#125;)</div><div class="line">makeRequest()</div></pre></td></tr></table></figure></p>
<blockquote>
<p>And this is how it looks with async/await</p>
</blockquote>
<p>用async/await会长这样<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> makeRequest = <span class="keyword">async</span> () =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> getJSON())</div><div class="line">  <span class="keyword">return</span> <span class="string">"done"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">makeRequest()</div></pre></td></tr></table></figure></p>
<blockquote>
<p>There are a few differences here</p>
<ol>
<li>Our function has the keyword async before it. The await keyword can only be used inside functions defined with async. Any async function returns a promise implicitly, and the resolve value of the promise will be whatever you return from the function (which is the string “done” in our case).</li>
<li>The above point implies that we can’t use await in the top level of our code since that is not inside an async function.</li>
<li>await getJSON() means that the console.log call will wait until getJSON() promise resolves and print it value.</li>
</ol>
</blockquote>
<p>有几点不同</p>
<ol>
<li>我们的函数前面有一个关键字<code>async</code>，<code>await</code>关键字只能在<code>async</code>定义的函数内部使用，任何<code>async</code>函数返回一个隐式的promise，并且这个promise的resolve将会是这个函数中的<code>return</code>（在上例中是字符串<code>&quot;node&quot;</code>）。</li>
<li><p>前面一点暗示了我们不能在代码的最外层使用await，因为那不再一个<code>async</code>函数内部。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// this will not work in top level</span></div><div class="line"><span class="comment">// await makeRequest()</span></div><div class="line"></div><div class="line"><span class="comment">// this will work</span></div><div class="line">makeRequest().then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</div><div class="line">  <span class="comment">// do something</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p><code>await getJSON()</code>意味着<code>console.log()</code>的调用会等到<code>getJSON()</code>resolve之后。</p>
</li>
</ol>
<blockquote>
<p>Why Is It better?<br>1.Concise and clean<br>Look at how much code we didn’t write! Even in the contrived example above, it’s clear we saved a decent amount of code. We didn’t have to write .then, create an anonymous function to handle the response, or give a name data to a variable that we don’t need to use. We also avoided nesting our code. These small advantages add up quickly, which will become more obvious in the following code examples.</p>
</blockquote>
<h3 id="为什么async-await更好？"><a href="#为什么async-await更好？" class="headerlink" title="为什么async/await更好？"></a>为什么async/await更好？</h3><h4 id="1-简洁干净"><a href="#1-简洁干净" class="headerlink" title="1. 简洁干净"></a>1. 简洁干净</h4><p>看一看我们少写了多少代码！甚至在上面故意这样写的例子里，显然我们节省了大量代码。我们不用写<code>.then</code>，不用创建一个匿名函数来处理response，或者是给<code>data</code>赋值给一个我们不需要的变量，我们也避免了嵌套代码。这些小的优点汇聚起来，将在接下来的例子中更加明显。</p>
<blockquote>
<p>2.Error handling<br>Async/await makes it finally possible to handle both synchronous and asynchronous errors with the same construct, good old try/catch. In the example below with promises, the try/catch will not handle if JSON.parse fails because it’s happening inside a promise. We need to call .catch on the promise and duplicate our error handling code, which will (hopefully) be more sophisticated than console.log in your production ready code.</p>
</blockquote>
<h4 id="2-异常处理"><a href="#2-异常处理" class="headerlink" title="2. 异常处理"></a>2. 异常处理</h4><p>async/await 终于让使用同样的结构，好并且成熟的<code>try/catch</code>来处理同步和异步异常成为可能。在下面使用promise的例子中，当<code>JSON.parse</code>失败时，<code>try/catch</code>不会去处理异常，因为错误在promise内部产生，我们需要在promise上调用<code>.catch</code>并重复你异常处理的代码。这用法看起来会比在你的成品代码里使用<code>console.log</code>更加成熟。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> makeRequest = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    getJSON()</div><div class="line">      .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</div><div class="line">        <span class="comment">// this parse may fail</span></div><div class="line">        <span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse(result)</div><div class="line">        <span class="built_in">console</span>.log(data)</div><div class="line">      &#125;)</div><div class="line">      <span class="comment">// uncomment this block to handle asynchronous errors</span></div><div class="line">      <span class="comment">// .catch((err) =&gt; &#123;</span></div><div class="line">      <span class="comment">//   console.log(err)</span></div><div class="line">      <span class="comment">// &#125;)</span></div><div class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</div><div class="line">    <span class="built_in">console</span>.log(err)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>Now look at the same code with async/await. The catch block now will handle parsing errors.</p>
</blockquote>
<p>现在来看一下相同的代码使用async/await，<code>catch</code>代码块将会处理解析异常。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> makeRequest = <span class="keyword">async</span> () =&gt; &#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">// this parse may fail</span></div><div class="line">    <span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse(<span class="keyword">await</span> getJSON())</div><div class="line">    <span class="built_in">console</span>.log(data)</div><div class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</div><div class="line">    <span class="built_in">console</span>.log(err)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>3.Conditionals<br>Imagine something like the code below which fetches some data and decides whether it should return that or get more details based on some value in the data.</p>
</blockquote>
<h4 id="3-条件语句"><a href="#3-条件语句" class="headerlink" title="3. 条件语句"></a>3. 条件语句</h4><p>想象一下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> makeRequest = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> getJSON()</div><div class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">if</span> (data.needsAnotherRequest) &#123;</div><div class="line">        <span class="keyword">return</span> makeAnotherRequest(data)</div><div class="line">          .then(<span class="function"><span class="params">moreData</span> =&gt;</span> &#123;</div><div class="line">            <span class="built_in">console</span>.log(moreData)</div><div class="line">            <span class="keyword">return</span> moreData</div><div class="line">          &#125;)</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(data)</div><div class="line">        <span class="keyword">return</span> data</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>Just looking at this gives you a headache. It’s easy to get lost in all that nesting (6 levels), braces, and return statements that are only needed to propagate the final result up to the main promise.<br>This example becomes way more readable when rewritten with async/await.</p>
</blockquote>
<p>（上面的代码）只是看着就会头痛。很容易让人迷失在嵌套（6层），支架（？）和返回由主要promise来产生最终结果所需要的声明之中。<br>这个例子实现了一种用async/await重写的更可读的方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> makeRequest = <span class="keyword">async</span> () =&gt; &#123;</div><div class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> getJSON()</div><div class="line">  <span class="keyword">if</span> (data.needsAnotherRequest) &#123;</div><div class="line">    <span class="keyword">const</span> moreData = <span class="keyword">await</span> makeAnotherRequest(data);</div><div class="line">    <span class="built_in">console</span>.log(moreData)</div><div class="line">    <span class="keyword">return</span> moreData</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(data)</div><div class="line">    <span class="keyword">return</span> data</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>4.Intermediate values<br>You have probably found yourself in a situation where you call a promise1 and then use what it returns to call promise2, then use the results of both promises to call a promise3. Your code most likely looked like this</p>
</blockquote>
<h4 id="4-中间值"><a href="#4-中间值" class="headerlink" title="4. 中间值"></a>4. 中间值</h4><p>你可能发现你经常遇到这样的情况：你调用一个<code>promise1</code>然后用它的返回值去调用<code>promise2</code>然后用它的返回值去调用<code>promise3</code>.你的代码看起来会是这样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> makeRequest = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> promise1()</div><div class="line">    .then(<span class="function"><span class="params">value1</span> =&gt;</span> &#123;</div><div class="line">      <span class="comment">// do something</span></div><div class="line">      <span class="keyword">return</span> promise2(value1)</div><div class="line">        .then(<span class="function"><span class="params">value2</span> =&gt;</span> &#123;</div><div class="line">          <span class="comment">// do something</span></div><div class="line">          <span class="keyword">return</span> promise3(value1, value2)</div><div class="line">        &#125;)</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>If promise3 didn’t require value1 it would be easy to flatten the promise nesting a bit. If you are the kind of person who couldn’t live with this, you could wrap both values 1 &amp; 2 in a Promise.all and avoid deeper nesting, like this</p>
</blockquote>
<p>如果<code>promise3</code>不依赖<code>value1</code>，那么退出promise会简单一些。如果你是那种不能忍受这样写的人，你可以把value1和2都包在一个<code>Promise.all</code>里，同时也避免了更深的嵌套，就像这样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> makeRequest = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> promise1()</div><div class="line">    .then(<span class="function"><span class="params">value1</span> =&gt;</span> &#123;</div><div class="line">      <span class="comment">// do something</span></div><div class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.all([value1, promise2(value1)])</div><div class="line">    &#125;)</div><div class="line">    .then(<span class="function">(<span class="params">[value1, value2]</span>) =&gt;</span> &#123;</div><div class="line">      <span class="comment">// do something</span></div><div class="line">      <span class="keyword">return</span> promise3(value1, value2)</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>This approach sacrifices semantics for the sake of readability. There is no reason for value1 &amp; value2 to belong in an array together, except to avoid nesting promises.<br>This same logic becomes ridiculously simple and intuitive with async/await. It makes you wonder about all the things you could have done in the time that you spent struggling to make promises look less hideous.</p>
</blockquote>
<p>这个方法牺牲了语法来获得可读性，没有理由让<code>value1</code>和<code>value2</code>都属于同一个数组，除非是为了避免嵌套promise。<br>相同的逻辑用async/await将变得非常简单并且浅显易懂。这会让你怀疑你能用原本花费在绞尽脑汁让promise看起来不那么丑的时间来完成所有事情。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> makeRequest = <span class="keyword">async</span> () =&gt; &#123;</div><div class="line">  <span class="keyword">const</span> value1 = <span class="keyword">await</span> promise1()</div><div class="line">  <span class="keyword">const</span> value2 = <span class="keyword">await</span> promise2(value1)</div><div class="line">  <span class="keyword">return</span> promise3(value1, value2)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>5.Error stacks<br>Imagine a piece of code that calls multiple promises in a chain, and somewhere down the chain an error is thrown.</p>
</blockquote>
<h4 id="5-异常栈"><a href="#5-异常栈" class="headerlink" title="5. 异常栈"></a>5. 异常栈</h4><p>想象一片链式调用了多个promise的代码，在调用的某处抛出了异常。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> makeRequest = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> callAPromise()</div><div class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> callAPromise())</div><div class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> callAPromise())</div><div class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> callAPromise())</div><div class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> callAPromise())</div><div class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"oops"</span>);</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">makeRequest()</div><div class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(err);</div><div class="line">    <span class="comment">// output</span></div><div class="line">    <span class="comment">// Error: oops at callAPromise.then.then.then.then.then (index.js:8:13)</span></div><div class="line">  &#125;)</div></pre></td></tr></table></figure></p>
<blockquote>
<p>The error stack returned from a promise chain gives no clue of where the error happened. Even worse, it’s misleading; the only function name it contains is callAPromise which is totally innocent of this error (the file and line number are still useful though).<br>However, the error stack from async/await points to the function that contains the error</p>
</blockquote>
<p>异常栈由promise链返回，不知道到底是哪里发生了异常。甚至会出更坏的情况：误导。只包含唯一的函数名<code>callAPromise</code>，它在这个异常中完全错误（虽然文件和行号依然能用）。<br>然而，由async/await得到的异常栈会指向包含错误的函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> makeRequest = <span class="keyword">async</span> () =&gt; &#123;</div><div class="line">  <span class="keyword">await</span> callAPromise()</div><div class="line">  <span class="keyword">await</span> callAPromise()</div><div class="line">  <span class="keyword">await</span> callAPromise()</div><div class="line">  <span class="keyword">await</span> callAPromise()</div><div class="line">  <span class="keyword">await</span> callAPromise()</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"oops"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">makeRequest()</div><div class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(err);</div><div class="line">    <span class="comment">// output</span></div><div class="line">    <span class="comment">// Error: oops at makeRequest (index.js:7:9)</span></div><div class="line">  &#125;)</div></pre></td></tr></table></figure></p>
<blockquote>
<p>This is not a huge plus when you’re developing on your local environment and have the file open in an editor, but it’s quite useful when you’re trying to make sense of error logs coming from your production server. In such cases, knowing the error happened in makeRequest is better than knowing that the error came from a then after a then after a then</p>
</blockquote>
<p>当你在本地环境，用编辑器开着文件开发，对你而言不是一个很大的好事，但是当你想从生产服务器搞清楚错误输出的话，这将会非常有用。这种情况下，知道异常出现在<code>makeRequest</code>里比知道异常从一堆<code>then</code>里好了不少。</p>
<blockquote>
<p>6.Debugging<br>Last but not least, a killer advantage when using async/await is that it’s much easier to debug. Debugging promises has always been such a pain for 2 reasons<br>1.You can’t set breakpoints in arrow functions that return expressions (no body).</p>
</blockquote>
<h4 id="6-Debugging"><a href="#6-Debugging" class="headerlink" title="6. Debugging"></a>6. Debugging</h4><p>最后但同样重要的一点，async/await的杀手锏是它debug起来更加简单，promise进行debug有两个导致他异常痛苦的原因：</p>
<ol>
<li><p>你不能在一列返回表达式的函数上打断点。<br><img src="https://cdn-images-1.medium.com/max/800/1*n_V4LaVdBOFgGCbmTR_VKA.png" alt=""></p>
<blockquote>
<ol>
<li>If you set a breakpoint inside a .then block and use debug shortcuts like step-over, the debugger will not move to the the following .then because it only “steps” through synchronous code.<br>With async/await you don’t need arrow functions as much, and you can step through await calls exactly as if they were normal synchronous calls.</li>
</ol>
</blockquote>
</li>
<li><p>如果你在<code>.then</code>代码块内部打断点，并且用了bebug的快捷方式，比如step-over，debugger不会执行下一个<code>.then</code>因为他只能在同步代码中执行。<br>用async/await的话你不需要一列函数，并且你可以单步调试await来像普通同步代码一样调用。<br><img src="https://cdn-images-1.medium.com/max/800/1*GWYd4eLrs0U96MkNNVB56A.png" alt=""></p>
</li>
</ol>
<blockquote>
<p>In Conclusion<br>Async/await is one of the most revolutionary features that have been added to JavaScript in the past few years. It makes you realize what a syntactical mess promises are, and provides an intuitive replacement.</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>async/await是近几年javascript新增的最具革命性的特性之一。它能让你实现与杂乱的promise等价的功能，同时提供了直接了当的替换方案。</p>
<blockquote>
<p>Concerns<br>Some valid skepticism you might have about using this feature<br>It makes asynchronous code less obvious: Our eyes learned to spot asynchronous code whenever we see a callback or a .then, it will take a few weeks for your eyes to adjust to the new signs, but C# had this feature for years and people who are familiar with it know it’s worth this minor, temporary inconvenience.<br>Node 7 is not an LTS release: Yes, but node 8 is coming next month, and migrating you codebase to the new version will most likely take little to no effort.</p>
</blockquote>
<h3 id="关注点"><a href="#关注点" class="headerlink" title="关注点"></a>关注点</h3><p>你需要了解关于这个特性的一些有意义的质疑</p>
<ul>
<li>它会让异步代码更加不显眼：我们的眼睛习惯了当看到回调或者<code>.then</code>进而关注异步代码，这将会花费你几周来让你的眼睛适应新写法，但是C#许多年前就有这个特性，并且熟悉这种写法的人知道这种写法带来的好处远远值得去克服这些很小的麻烦。</li>
<li>node7还不是LTS版本：是的，但是node8下个月（原文发布于2017年3月26日）就要出了。迁移你的代码库到新版本将很可能不需要花费太大力气。</li>
</ul>

    </div>
</div>
  <footer class="footer">
  <p> powered by hexo</p>
</footer>
<script>
  var max = document.getElementsByClassName("btn")[1];
  var min = document.getElementsByClassName("btn")[2];

  function maximize () {
    var post = document.getElementsByClassName("content")[0];
    var cont = document.getElementsByClassName("post_content")[0];
    var wid = window.innerWidth || document.documentElement.clientWidth || document.getElementsByTagName("body")[0].clientWidth;

    if (wid > 900) {
      widf = wid * 0.9;
      post.style.width = widf + "px";

      if (wid < 1400) {
        cont.style.width = "99%";
      } else {
        cont.style.width = "99.4%";
      }
    }
  }

  function minimize () {
    var post = document.getElementsByClassName("content")[0];
    var cont = document.getElementsByClassName("post_content")[0];
    var wid = window.innerWidth || document.documentElement.clientWidth || document.getElementsByTagName("body")[0].clientWidth;

    if ( wid > 900 ) {
      post.style.width = "800px";
      cont.style.width = "98.5%";
    }
  }

  max && max.addEventListener('click', maximize, false);
  min && min.addEventListener('click', minimize, false);

</script>
</body>
</html>