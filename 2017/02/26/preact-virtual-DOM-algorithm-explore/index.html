<!DOCTYPE html>
<html lang=en,zh-cn,default>
  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="description" content="这里什么都没有">
  <meta name="keywords" content="undefined">
  
    <link rel="icon" href="">
  
  <title>Preact Virtual DOM算法探究</title>
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/atom-one-light.css">
<link rel="stylesheet" href="/css/font-awesome.min.css">
  <script src="/js/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body>
  <div class="wrapper">
    <div class="default_title">
        <img src="/imgs/mycomputer.png" />
        <h1>香香鸡的小窝</h1>
    </div>
    <ul class="topbar">
    
        <li>
        <a href="/" class="item-link">首页</a>
        </li>
    
        <li>
        <a href="/about" class="item-link">关于</a>
        </li>
    
    </ul>
    <div class="tag_list">
    <ul id="tag-list">
        <li><a href="/" ><img src="/imgs/disk.png" />(C:)</a>
        <ul>
        
            <li>
            <a href="/tags/GraphQL" title="GraphQL" rel="1">
                <img src="/imgs/folder.ico" />
                GraphQL
            </a>
            </li>    
        
            <li>
            <a href="/tags/Relay" title="Relay" rel="1">
                <img src="/imgs/folder.ico" />
                Relay
            </a>
            </li>    
        
            <li>
            <a href="/tags/Vue" title="Vue" rel="3">
                <img src="/imgs/folder.ico" />
                Vue
            </a>
            </li>    
        
            <li>
            <a href="/tags/javascript" title="javascript" rel="3">
                <img src="/imgs/folder.ico" />
                javascript
            </a>
            </li>    
        
            <li>
            <a href="/tags/Typescript" title="Typescript" rel="1">
                <img src="/imgs/folder.ico" />
                Typescript
            </a>
            </li>    
        
            <li>
            <a href="/tags/redux-saga" title="redux-saga" rel="1">
                <img src="/imgs/folder.ico" />
                redux-saga
            </a>
            </li>    
        
            <li>
            <a href="/tags/redux-observable" title="redux-observable" rel="1">
                <img src="/imgs/folder.ico" />
                redux-observable
            </a>
            </li>    
        
            <li>
            <a href="/tags/React" title="React" rel="1">
                <img src="/imgs/folder.ico" />
                React
            </a>
            </li>    
        
            <li>
            <a href="/tags/Preact" title="Preact" rel="1">
                <img src="/imgs/folder.ico" />
                Preact
            </a>
            </li>    
        
            <li>
            <a href="/tags/Virtual DOM" title="Virtual DOM" rel="1">
                <img src="/imgs/folder.ico" />
                Virtual DOM
            </a>
            </li>    
        
            <li>
            <a href="/tags/Reason" title="Reason" rel="1">
                <img src="/imgs/folder.ico" />
                Reason
            </a>
            </li>    
        
            <li>
            <a href="/tags/OCaml" title="OCaml" rel="1">
                <img src="/imgs/folder.ico" />
                OCaml
            </a>
            </li>    
        
            <li>
            <a href="/tags/bucklescript" title="bucklescript" rel="1">
                <img src="/imgs/folder.ico" />
                bucklescript
            </a>
            </li>    
        
        </ul>
    </ul>
    </div>
    <div class="post_list">
    <ul>
        
            <li>
            <a href="/2017/02/22/GraphQL-Relay-first-explore/">
            <img src="/imgs/file.ico" />
                GraphQL+Relay初探
            </a>
            </li>
        
            <li>
            <a href="/2016/08/20/The-State-of-Vue/">
            <img src="/imgs/file.ico" />
                The State of Vue(自译)
            </a>
            </li>
        
            <li>
            <a href="/2017/04/05/6-reasons-why-javascripts-async-await-blows-promises-away/">
            <img src="/imgs/file.ico" />
                Async/Await胜过Promise的6个理由（自译）
            </a>
            </li>
        
            <li>
            <a href="/2018/03/12/dose-refactoring-vue-project-into-typescript-deserved/">
            <img src="/imgs/file.ico" />
                有必要将Vue项目重构到Typescript吗?
            </a>
            </li>
        
            <li>
            <a href="/2017/03/30/i-dont-know-js/">
            <img src="/imgs/file.ico" />
                我不懂的js集合
            </a>
            </li>
        
            <li>
            <a href="/2016/09/10/vue-directive-to-highlight-code/">
            <img src="/imgs/file.ico" />
                vue自定义指令实现Highlight.js高亮代码
            </a>
            </li>
        
            <li>
            <a href="/2017/02/26/preact-virtual-DOM-algorithm-explore/">
            <img src="/imgs/file.ico" />
                Preact Virtual DOM算法探究
            </a>
            </li>
        
            <li>
            <a href="/2017/12/17/reason-intro/">
            <img src="/imgs/file.ico" />
                Reason简介
            </a>
            </li>
        
    </ul>
    </div>

    <div class="post_total">
        
            <div class="left">8 object(s)</div>
        
        <div class="right">&nbsp;</div>
    </div>
</div>
  <div class="content">
    <div class="post_title">
      <img src="/imgs/file.png" />
      <h1>Preact Virtual DOM算法探究</h1>
      <a href="/"><div class="btn"><span class="fa fa-times"></span></div></a>
      <div class="btn btn_max"><span class="fa fa-window-maximize"></span></div>
      <div class="btn"><span class="fa fa-window-minimize"></span></div>
    </div>
    <ul class="topbar">
      <li>Sun Feb 26 2017 13:50:19 GMT+0800</li>
    </ul>
    <div class="post_content">
      <h3 id="Preact简介"><a href="#Preact简介" class="headerlink" title="Preact简介"></a>Preact简介</h3><p><img src="http://olu3hx27t.bkt.clouddn.com/image/preact.png?imageView2/2/w/200/h/100" alt=""><br>Preact是一个React轻量化的库，整个库大小只有3kb，相比其他react轻量化的方案，如25kb的<a href="https://github.com/Lucifier129/react-lite" target="_blank" rel="external">react-lite</a>，Preact在体积上有着很大的优势。<br>Preact有着和React相似的API，大部分情况下能兼容React的组件，只需要绑定一个preact-compat兼容层就能解决很多兼容问题。类似React的生态圈，Preact自己也有着规模不小的生态圈。<br>同时官网也宣称Preact有着一个简单却高效的diff算法实现使他成为最快的虚拟DOM框架之一，官网也号称自己可能是最薄的一层虚拟DOM实现。接下来本文将简单探究一下preact的虚拟DOM算法, 同时对比一下于React的Vitrual DOM算法的区别</p>
<h3 id="Preact的Virtual-DOM实现"><a href="#Preact的Virtual-DOM实现" class="headerlink" title="Preact的Virtual DOM实现"></a>Preact的Virtual DOM实现</h3><p>React使用<code>React.createElement()</code>来实现js转换为Virtual DOM的过程，Preact在这里用了自己的实现方式。<br>Preact的Virtual DOM实现使用了<a href="https://www.npmjs.com/package/babel-plugin-transform-react-jsx" target="_blank" rel="external">babel-plugin-transform-react-jsx</a>，通过pragma注入一个函数<code>preact.h</code>，实现类似下面的转换<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** @jsx h */</span></div><div class="line"><span class="keyword">let</span> foo = <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'foo'</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">//After babel transpilation</span></div><div class="line"><span class="keyword">var</span> foo = h(<span class="string">'div'</span>, &#123;<span class="attr">id</span>: <span class="string">'foo'</span>&#125;, <span class="string">'Hello'</span>);</div></pre></td></tr></table></figure></p>
<p>Preact利用<code>Preact.h()</code>函数来将转换后的js生成Virtual DOM，之后再利用自己的Virtual DOM算法将其转换为真实的DOM。<br>Preact.h()这个函数为<a href="https://github.com/hyperhype/hyperscript" target="_blank" rel="external">hyperscript</a>的一个简化版，有兴趣的读者可以去了解完整的hyperscript。</p>
<h3 id="Preact的Virtual-DOM算法"><a href="#Preact的Virtual-DOM算法" class="headerlink" title="Preact的Virtual DOM算法"></a>Preact的Virtual DOM算法</h3><h4 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h4><p>h函数接受babel转换后的代码，生成一系列的VNode(也就是Virtual DOM)，之后执行<code>render()</code>函数，例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">render(h(Foo), <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>))</div></pre></td></tr></table></figure></p>
<p>h()函数会将Foo转为如下的VNode<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"nodeName"</span>: <span class="string">"Foo"</span>,</div><div class="line">    <span class="attr">"children"</span>: []</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>之后会根据VNode.nodeName的类型分为以下几种情况</p>
<h5 id="为组件创建VNode的实例"><a href="#为组件创建VNode的实例" class="headerlink" title="为组件创建VNode的实例"></a>为组件创建VNode的实例</h5><p>如果当前这个VNode.nodeName是一个组件，且还未被实例化，则会先去创建这个组件的实例，然后去先后调用这个组件的<code>componentWillMount</code>和<code>render</code>生命周期，其中<code>render()</code>会多次调用<code>h()</code>函数，最终让VNode变成类似下面的结构<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"nodeName"</span>: <span class="string">"div"</span>,</div><div class="line">    <span class="attr">"children"</span>: [</div><div class="line">        &#123;</div><div class="line">            <span class="attr">"nodeName"</span>: <span class="string">"input"</span>,</div><div class="line">            <span class="attr">"attribute"</span>: &#123;</div><div class="line">                <span class="attr">"type"</span>: <span class="string">"text"</span>,</div><div class="line">                <span class="attr">"onChange"</span>: <span class="string">""</span>,</div><div class="line">                <span class="attr">"placeholder"</span>: <span class="string">"input here"</span></div><div class="line">            &#125;,</div><div class="line">            <span class="attr">"children"</span>: []</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            <span class="attr">"nodeName"</span>: <span class="string">"List"</span>,</div><div class="line">            <span class="attr">"attribute"</span>: &#123;</div><div class="line">                <span class="attr">"items"</span>: [</div><div class="line">                    <span class="string">"foo"</span>,</div><div class="line">                    <span class="string">"bar"</span>,</div><div class="line">                ]</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">"children"</span>: []</div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>需要注意的是，上面的节点的第二个子节点为一个组件，在这里并没有被转换。<br><code>render()</code>函数执行完后会又重复根据VNode.nodeName类型进行判断</p>
<p>与组件相关的函数一共有四个，分别为</p>
<ul>
<li><code>setComponentProps()</code>: 为组件设立props</li>
<li><code>renderComponent()</code>: 渲染一个组件，在这个函数内部会触发一些生命周期的钩子以及接收高阶组件</li>
<li><code>buildComponentFromVNode()</code>: 将来自VNode的组件变为真实DOM</li>
<li><code>unmoumtComponent()</code>: 将组件从DOM树中移除，并回收它</li>
</ul>
<h5 id="为非组件直接创建真实DOM节点"><a href="#为非组件直接创建真实DOM节点" class="headerlink" title="为非组件直接创建真实DOM节点"></a>为非组件直接创建真实DOM节点</h5><p>当VNode.nodeName为非组件(即HTML标签)，且还没有相同的真实DOM节点已经被渲染，则会去用<code>document.createNode(node)</code>创建新的节点。<br>如果这个节点还有子节点的话，则会循环这个过程来重复创建子节点。</p>
<h5 id="子节点添加到父节点"><a href="#子节点添加到父节点" class="headerlink" title="子节点添加到父节点"></a>子节点添加到父节点</h5><p>当上一步中判断节点没有子节点时，会接着判断该节点是否有父节点，若有父节点则会调用父节点的<code>appendChild(childNode)</code>方法来将子节点添加到父节点。</p>
<blockquote>
<p>创建完子节点A（A无子节点）后并不会立即去创建子节点B，而是会先将子节点A添加到父节点，再去创建子节点B</p>
</blockquote>
<h5 id="处理子组件"><a href="#处理子组件" class="headerlink" title="处理子组件"></a>处理子组件</h5><p>当子节点为一个组件时，流程与前面类似，先为该组件创建VNode，再对其子节点进行前面流程的操作。<br>最终处理完该组件(以前面的List组件为例)的VNode类似如下结构：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"nodeName"</span>: <span class="string">"ul"</span>,</div><div class="line">    <span class="attr">"children"</span>: [</div><div class="line">        &#123;</div><div class="line">            <span class="attr">"nodeName"</span>: <span class="string">"li"</span>,</div><div class="line">            <span class="attr">"attribute"</span>: &#123;</div><div class="line">                <span class="attr">"key"</span>: <span class="string">"foo"</span></div><div class="line">            &#125;,</div><div class="line">            <span class="attr">"children"</span>: [</div><div class="line">                <span class="string">"foo"</span></div><div class="line">            ],</div><div class="line">            <span class="attr">"key"</span>: <span class="string">"foo"</span></div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            <span class="attr">"nodeName"</span>: <span class="string">"li"</span>,</div><div class="line">            <span class="attr">"attribute"</span>: &#123;</div><div class="line">                <span class="attr">"key"</span>: <span class="string">"bar"</span></div><div class="line">            &#125;,</div><div class="line">            <span class="attr">"children"</span>: [</div><div class="line">                <span class="string">"bar"</span></div><div class="line">            ],</div><div class="line">            <span class="attr">"key"</span>: <span class="string">"bar"</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="结束处理"><a href="#结束处理" class="headerlink" title="结束处理"></a>结束处理</h5><p>多次重复前面的流程，所有的节点以及挂载之后（即当前处理的VNode没有父节点），会调用<code>componentDidMount</code>函数，结束处理。</p>
<blockquote>
<p>在这之后，组件会保持一个对真实DOM的引用(refs)，引用会用于更新和对比，能避免重复创建相同的节点。</p>
</blockquote>
<h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><p>删除节点的过程中，涉及到了组件的更新、删除节点和组件的卸载</p>
<h5 id="更新VNode"><a href="#更新VNode" class="headerlink" title="更新VNode"></a>更新VNode</h5><p>在判断完VNode.nodeName为组件并且该组件以及存在后，会去先后调用<code>componentWillReceiveProps</code>, <code>shouldComponentUpdate</code>和<code>componentWillUpdate</code>的生命钩子，之后再去调用<code>render</code></p>
<blockquote>
<p>如果在这个流程中<code>shouldComponentUpdate</code>返回了false，则会直接跳过<code>componentWillUpdate</code>和<code>render</code>，这也就是<code>shouldComponentUpdate</code>用于优化react／preact性能的原理。</p>
</blockquote>
<h5 id="引用真实DOM"><a href="#引用真实DOM" class="headerlink" title="引用真实DOM"></a>引用真实DOM</h5><p>先前已经创建过的组件会保持对真实DOM的引用，在更新后，他的每一个属性都会和真实DOM的属性比较，如果是没有变化，则会跳过这个节点，去处理下一个节点，从而实现避免重复创建。</p>
<h5 id="完全删除节点"><a href="#完全删除节点" class="headerlink" title="完全删除节点"></a>完全删除节点</h5><p>当节点找不到与之相同的真实DOM，也不在创建节点的情况下，则会去删除(remove)该节点。<br>该节点不为组件的情况下，其父节点会简单的调用<code>removeChild(node)</code>来删除节点，在这之后会触发<code>ComponentDidUpdate</code>生命钩子。</p>
<h5 id="卸载组件"><a href="#卸载组件" class="headerlink" title="卸载组件"></a>卸载组件</h5><p>类似上面完全删除节点的情况，如果即将删除的为一个组件，则会先调用<code>ComponentWillUnMount</code>，之后去调用<code>component.unmoumtComponent()</code>，删除完之后调用<code>ComponentDidMounted</code>。</p>
<h4 id="DOM-Diff"><a href="#DOM-Diff" class="headerlink" title="DOM Diff"></a>DOM Diff</h4><p>上面的Virtual DOM算法在具体实现中会多次用到DOM Diff算法进行对比。<br>在探索Preact的DOM Diff算法之前，先简单了解一下React的DOM Diff算法：</p>
<h5 id="React的DOM-Diff算法"><a href="#React的DOM-Diff算法" class="headerlink" title="React的DOM Diff算法"></a>React的DOM Diff算法</h5><p>React的DOM Diff算法在标准Diff算法的基础上改进，将时间复杂度从O(n^3)减少到了O(n)，能做到这样是因为React的diff算法基于了两点假设：</p>
<blockquote>
<p>1.Two elements of different types will produce different trees.<br>  两个不同类型的元素会生成不同的DOM树<br>2.The developer can hint at which child elements may be stable across different renders with a key prop.<br>  开发者可以用给子元素加上<code>key</code>这个prop来让其能在多次渲染时保持稳定<br>  (关于第二点，网上部分资料给出的为 对于同一层次的一组子节点，它们可以通过唯一的id进行区分)</p>
</blockquote>
<p>其DOM Diff算法主要分为三类情况，tree diff，component diff和element diff。<br>（关于React DOM Diff的文章很多，本文就不在这里赘述）</p>
<h5 id="Preact的DOM-Diff算法"><a href="#Preact的DOM-Diff算法" class="headerlink" title="Preact的DOM Diff算法"></a>Preact的DOM Diff算法</h5><p>阅读过源码的读者不难发现，前面提到的<code>render()</code>函数本质上是调用了diff函数，而diff函数的具体实现中会涉及到以下函数</p>
<ul>
<li><code>idiff()</code>：<code>diff()</code>主要会调用这个函数，去进行具体的对比</li>
<li><code>diffAttributes()</code>：对比节点的具体属性<br>（待补完）<h3 id="关于具体的性能测试"><a href="#关于具体的性能测试" class="headerlink" title="关于具体的性能测试"></a>关于具体的性能测试</h3><a href="http://developit.github.io/js-repaint-perfs/" target="_blank" rel="external">REPAINT RATE CHALLENGE</a><br><a href="https://localvoid.github.io/uibench/" target="_blank" rel="external">UI Benchmark</a></li>
</ul>

    </div>
</div>
  <footer class="footer">
  <p> powered by hexo</p>
</footer>
<script>
  var max = document.getElementsByClassName("btn")[1];
  var min = document.getElementsByClassName("btn")[2];

  function maximize () {
    var post = document.getElementsByClassName("content")[0];
    var cont = document.getElementsByClassName("post_content")[0];
    var wid = window.innerWidth || document.documentElement.clientWidth || document.getElementsByTagName("body")[0].clientWidth;

    if (wid > 900) {
      widf = wid * 0.9;
      post.style.width = widf + "px";

      if (wid < 1400) {
        cont.style.width = "99%";
      } else {
        cont.style.width = "99.4%";
      }
    }
  }

  function minimize () {
    var post = document.getElementsByClassName("content")[0];
    var cont = document.getElementsByClassName("post_content")[0];
    var wid = window.innerWidth || document.documentElement.clientWidth || document.getElementsByTagName("body")[0].clientWidth;

    if ( wid > 900 ) {
      post.style.width = "800px";
      cont.style.width = "98.5%";
    }
  }

  max && max.addEventListener('click', maximize, false);
  min && min.addEventListener('click', minimize, false);

</script>
</body>
</html>